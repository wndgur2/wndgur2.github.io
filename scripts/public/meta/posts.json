[
  {
    "id": "posts/study/js_heap.md",
    "category": "Study",
    "title": "JS로 힙(heap) 구현하기",
    "content": "\n![heap](https://github.com/user-attachments/assets/d1f75775-8196-40ef-9c65-5998e1ee4b56)\n\n## javascript로 왜 힙을 구현해야할까?\n\njs로 알고리즘을 풀다 보니, 구현해야하는 자료구조들이 있었다.\n\n특히 우선순위 큐가 그랬다.\n\n이를 직접 구현하는 것에 익숙하지 않다보니 해당 자료구조를 사용하지 않고 문제를 풀고자 하게 되었다.\n\n숙련도 때문에 문제 해결에 제약이 걸리는 것을 방지하고자 이를 구현하는 연습을 하고자 한다.\n\n아마 다음엔 Linked List를 통한 dequeue를 구현해볼 것 같다.\n\n\n> ### 목차\n> 1. 힙이란?  \n> 2. 힙 들여다보기  \n> 3. javascript로 힙 구현하기  \n\n## 1. 힙이란?\n\n완전이진트리의 한 종류이다.\n비교 연산을 통해 트리의 최고 우선 요소를 `root`로 가진다는 특징이 있다.\n\n예를 들어 비교 연산이 `<`(less than) 이라면 루트는 가장 작은 값을 가지게 되고 이를 `min-heap`이라 한다.\n\n트리를 사용한 덕분에 삽입과 삭제 연산이 `O(logN)` 만에 수행된다. 트리의 `depth` 만큼만 수행하면 되기 때문이다.\n\n주의해야할 점은, 모든 요소가 아니라 `부모-자식` 관계만 우선순위가 정렬되어있다는 점이다. 이 때문에 보통 중간 노드가 아닌 `top`을 뽑아 쓰는 용도로만 사용한다.\n\n## 2. 힙 들여다보기\n\n그럼 이 완전이진트리인 힙은 어떻게 정렬을 유지하는지 삽입과 삭제 과정을 살펴보자.\n여기서는 편의를 위해 `min-heap`을 예시로 적었다.\n\n### 2-1 삽입 insert(Node)\n\n<img alt=\"heap_insert\" src=\"https://github.com/user-attachments/assets/0c051d79-0632-49bf-a6d7-33863f578b1c\" />\n\n맨 마지막에 `새로운 노드`를 추가하고, 이 `새로운 노드`를 알맞은 `depth`까지 끌어올린다. (이를 sift up 과정이라 부른다.)  \n`min-heap`의 경우 `새로운 노드의 부모 노드`가 `새로운 노드`보다 큰 값을 가질 경우 자리를 바꾸는 과정을 반복한다.\n\n트리의 `depth` 만큼 수행되므로 시간복잡도는 `O(logN)`가 된다.\n\n### 2-2 삭제 pop()\n  \n> heap에서의 삭제는, 보통 `root`를 삭제하는 `pop()`을 의미한다.  \n> `root`를 제외한 노드는 자료구조의 용도, 성능을 이유로 삭제를 구현하지는 않는 것 같다.\n\n<img alt=\"heap_pop\" src=\"https://github.com/user-attachments/assets/8bf4dd28-442e-4764-9fb5-7dcb6609bdb2\" />\n\n우선 `root` 자리를 마지막 노드로 대체한다. (삭제 후에도 완전 이진 트리를 유지하기 위한 좋은 방법 같다.) \n\n이제 `root` 노드를 적당한 자리로 보내기 위해 아래 과정을 거친다. (sift down 과정이라 부른다.)\n\n대체할 우선순위가 높은 자식 노드를 찾는다. `min-heap`에서는 더 작은 자식 노드가 `root`와 자리를 바꾸게 된다. \n\n내려간 자리에서 같은 과정을 반복한다. 즉, 리프노드가 되거나 자식들보다 본인의 우선순위가 높을 때까지 우선순위가 높은 자식노드와 자리를 바꾼다.\n\n트리의 `depth` 만큼 수행되므로 시간복잡도는 `O(logN)`가 된다.\n\n### 2-3 조회 top()\n\n트리의 `root`를 조회하여 값을 반환한다.\n\n트리의 `root`는 배열의 0번 인덱스로 즉시 접근 가능하므로 시간복잡도는 `O(1)`가 된다.\n\n## 3. javascript로 힙 구현하기\n\n완전이진트리는 배열로 쉽게 구현 가능하다. 인덱스 `i`의 자식을 `i*2+1`, `i*2`로 접근 가능하다.\n\n함수 `isPrior(a, b)`를 생성자의 인자로 두어 상황에 필요한 비교 연산을 넣을 수 있도록 했다.\n\n```javascript\n\n\n    class Heap {\n      constructor(isPrior) {\n        this.nodes = []\n        this.isPrior = isPrior \n      }\n\n      top () {\n        return this.nodes[0]\n      }\n\n      insert (node) {\n        this.nodes.push(node)\n        let i = this.nodes.length - 1\n\n        // sift up\n        while (i > 0) {\n          const pi = i - 1 >> 1\n          if (this.isPrior(this.nodes[i], this.nodes[pi])) {\n            ;[this.nodes[i], this.nodes[pi]] = [this.nodes[pi], this.nodes[i]]\n            i = pi\n          } else {\n            break\n          }\n        }\n      }\n\n      pop () {\n        if (this.nodes.length === 0) return\n\n        const res = this.nodes[0]\n        if (this.nodes.length === 1) {\n          this.nodes.pop()\n          return res\n        }\n\n        this.nodes[0] = this.nodes.pop()\n\n        const size = this.nodes.length\n        let i = 0\n\n        // sift down\n        while (true) {\n          const l = i * 2 + 1\n          const r = l + 1\n          let best = i\n\n          if (l < size && this.isPrior(this.nodes[l], this.nodes[best])) {\n            best = l\n          }\n          if (r < size && this.isPrior(this.nodes[r], this.nodes[best])) {\n            best = r\n          }\n\n          if (best === i) break\n\n            ;[this.nodes[i], this.nodes[best]] = [this.nodes[best], this.nodes[i]]\n          i = best\n        }\n\n        return res\n      }\n    }\n\n```\n\n생성 예\n\n```javascript\nconst pq = new Heap((a, b)=> a < b) // min-heap\n```",
    "tags": [
      "data-structure",
      "heap",
      "javascript",
      "priority-queue"
    ],
    "date_started": "2025.12.02",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/study/js_heap.md",
    "preview": ""
  },
  {
    "id": "posts/algorithm/카운트_디운.md",
    "category": "Algorithm",
    "title": "카운트 다운",
    "content": "\n# [문제](https://school.programmers.co.kr/learn/courses/30/lessons/131129#)\n## 문제 설명\n프로그래머스 다트 협회에서는 매년마다 새로운 특수 룰로 다트 대회를 개최합니다. 이번 대회의 룰은 **\"카운트 다운\"**으로 **\"제로원\"** 룰의 변형 룰입니다.  \n\n\"카운트 다운\"은 게임이 시작되면 무작위로 점수가 정해지고, 다트를 던지면서 점수를 깎아 정확히 0점으로 만드는 게임입니다.  \n단, 남은 점수보다 큰 점수로 득점하면 버스트가 되며 실격합니다.\n\n다음 그림은 다트 과녁입니다.  \n\n![Image](https://github.com/user-attachments/assets/7353a57f-16c2-4cfa-bcd0-9a3b6056481b)\n\n다트 과녁에는 1부터 20까지의 수가 하나씩 있고 각 수마다 \"싱글\", \"더블\", \"트리플\" 칸이 있습니다.  \n- \"싱글\": 해당 수만큼 점수 획득  \n- \"더블\": 해당 수의 두 배 점수 획득  \n- \"트리플\": 해당 수의 세 배 점수 획득  \n\n가운데에는 \"불\"과 \"아우터 불\"이 있는데 \"카운트 다운\" 게임에서는 구분 없이 50점을 얻습니다.\n\n대회는 토너먼트로 진행되며 한 게임에는 두 선수가 참가합니다. 게임은 두 선수가 교대로 한 번씩 던지는 라운드 방식으로 진행됩니다.  \n가장 먼저 0점을 만든 선수가 승리합니다.  \n만약 두 선수가 같은 라운드에 0점을 만들면, 두 선수 중 **\"싱글\" 또는 \"불\"을 더 많이 던진 선수**가 승리하며, 그마저도 같다면 **선공인 선수**가 승리합니다.\n\n다트 실력에 자신 있던 종호는 이 대회에 출전하기로 했습니다.  \n최소한의 다트로 0점을 만드는 게 가장 중요하고, 그러한 방법이 여러 가지가 있다면 \"싱글\" 또는 \"불\"을 최대한 많이 던지는 방법을 선택해야 합니다.\n\n목표 점수 `target`이 매개변수로 주어졌을 때,  \n- 최선의 경우 던질 다트 수와  \n- 그때의 \"싱글\" 또는 \"불\"을 맞춘 횟수(합)  \n\n를 순서대로 배열에 담아 return 하도록 `solution` 함수를 완성해 주세요.\n\n## 제한사항\n- 1 ≤ target ≤ 100,000  \n\n## 입출력 예\n| target | result |\n| ------ | ------ |\n| 21     | [1, 0] |\n| 58     | [2, 2] |\n\n## 입출력 예 설명\n### 입출력 예 #1\n- 7 트리플로 21점을 만들 수 있습니다.\n\n### 입출력 예 #2\n- 불 + 8 싱글로 58점을 만들 수 있습니다.\n\n# 문제 풀이\n\n첫 시도는 bfs였다.\n\ntarget이 최대 십만이기에 bfs 경우만 잘 정리하면 가능할 것 같았지만, 경우를 축소하기가 쉽지 않았다.\n\nbfs 코드를 작성하고 보니 dp 문제인게 보였다.\n\ntarget을 향해 point를 쌓아나가는 과정이 있기 때문이다.\n\n그 중에 try가 가장 적고, bullOrSingle이 가장 많은 경우를 고르면 된다.\n\n# 코드\n```javascript\n// target으로 가는 dp\n\nfunction solution(target) {\n    const dp = Array(100001).fill(0).map(v=>[-1,-1])\n    dp[0][0] = 0\n    dp[0][1] = 0\n    \n    for(let i=1; i<=20; i++){\n        dp[i][0]=1\n        dp[i][1]=1\n    }\n    dp[50][0]=1\n    dp[50][1]=1\n    \n    for(let i=0; i<=target; i++){\n        if(i>=50){\n            dp[i][0] = dp[i-50][0]+1\n            dp[i][1] = dp[i-50][1]+1\n        }\n        let d1;\n        for(let j=1; j<=20; j++){\n            for(let k=1; k<=3; k++){\n                if(k==1) d1=1\n                else d1=0\n                if(i-j*k<0) break\n                const newTries = dp[i-j*k][0] + 1\n                const newBullOrSingles = dp[i-j*k][1] + d1\n                \n                if(newTries<dp[i][0] ||\n                    newTries==dp[i][0] && newBullOrSingles>dp[i][1] ||\n                    dp[i][0]==-1\n                  ){\n                    dp[i][0] = newTries\n                    dp[i][1] = newBullOrSingles\n                }\n            }\n        }\n    }\n    return dp[target]\n}\n```",
    "tags": [
      "DP",
      "javascript"
    ],
    "date_started": "2025.09.22",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/algorithm/%EC%B9%B4%EC%9A%B4%ED%8A%B8_%EB%94%94%EC%9A%B4.md",
    "preview": ""
  },
  {
    "id": "posts/algorithm/도둑질.md",
    "category": "Algorithm",
    "title": "도둑질",
    "content": "\n# [문제](https://school.programmers.co.kr/learn/courses/30/lessons/42897?language=javascript#)\n## 문제 설명\n도둑이 어느 마을을 털 계획을 하고 있습니다. 이 마을의 모든 집들은 아래 그림과 같이 동그랗게 배치되어 있습니다.\n\n![Image](https://github.com/user-attachments/assets/577a0a63-9bc7-4e21-b93d-2cccd32f4221)\n\n각 집들은 서로 인접한 집들과 방범장치가 연결되어 있기 때문에 인접한 두 집을 털면 경보가 울립니다.\n\n각 집에 있는 돈이 담긴 배열 `money`가 주어질 때, 도둑이 훔칠 수 있는 돈의 최댓값을 return 하도록 `solution` 함수를 작성하세요.\n\n## 제한사항\n- 이 마을에 있는 집은 3개 이상 1,000,000개 이하입니다.  \n- `money` 배열의 각 원소는 0 이상 1,000 이하인 정수입니다.  \n\n## 입출력 예\n| money     | return |\n| --------- | ------ |\n| [1, 2, 3, 1] | 4 |\n\n# 문제 풀이\n\n전형적인 dp로 보였으나, 배열이 순환한다는 로직이 추가되었다.\n\n그래서 단순히 이전걸 쌓아가는것 뿐만 아니라, 마지막 원소에선 첫 원소를 선택하지 않았을 경우를 추가해야한다.\n\n그래서 첫 분기를 첫 원소를 선택한 경우와 선택하지 않은 경우로 나누었고,\n두번째 분기를 해당 원소를 선택한 경우와 선택하지 않은 경우로 나누어\n총 4개의 분기가 생겼다.\n\n그런데 효율성 테스트가 실패했다.\n여기서 시간복잡도는 더 줄일 수 없다고 느꼈고,\ndp 과정을 보니 index를 i와 i-1밖에 사용하지 않길래 dp를 두개만 유지하는 방법을 썼다. (왔다갔다 쓰기)\n\n왜 처음 원소를 선택하지 못하는 경우를 처음부터 처리했는가?\n\n이 부분은 내가 가장 효율적으로 풀이했는지는 확신하지 못한다.  \nboolean 값 두개로 대체할 수도 있을 것 같다.  \n그래도 고려한 경우를 늘리는 것이 dp에서 예외를 처리하는 가장 확실한 방법인 것 같다.\n\n# 코드\n```javascript\n\nfunction solution(money) {\n    const length = money.length\n    const dpA = [0,0,0,0]\n    const dpB = [0,0,0,0]\n    const dps = [dpA, dpB]\n    let curDp, prevDp\n    \n    dpA[0] = money[0]\n    \n    for(let i=1; i<length; i++){\n        curDp = dps[i%2]\n        prevDp = dps[(i+1)%2]\n        \n        // 0을 뽑은 경우\n        curDp[0] = prevDp[1] + money[i]\n        curDp[1] = max(prevDp[0], prevDp[1])\n        \n        // 0을 안 뽑은 경우\n        curDp[2] = prevDp[3] + money[i]\n        curDp[3] = max(prevDp[2], prevDp[3])\n        \n    }\n    \n    curDp[0] -= money[0]\n    \n    const a = max(curDp[0], curDp[1])\n    const b = max(curDp[2], curDp[3])\n    \n    \n    return max(a, b)\n}\n    \nfunction max(a, b){\n    if(a>b) return a\n    else return b\n}\n\n```",
    "tags": [
      "DP",
      "javascript"
    ],
    "date_started": "2025.09.22",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/algorithm/%EB%8F%84%EB%91%91%EC%A7%88.md",
    "preview": ""
  },
  {
    "id": "posts/algorithm/주사위_고르기.md",
    "category": "Algorithm",
    "title": "주사위 고르기",
    "content": "\n# [문제](https://school.programmers.co.kr/learn/courses/30/lessons/258709?language=javascript)\n## 문제 설명\nA와 B가 n개의 주사위를 가지고 승부를 합니다. 주사위의 6개 면에 각각 하나의 수가 쓰여 있으며, 주사위를 던졌을 때 각 면이 나올 확률은 동일합니다. 각 주사위는 1 ~ n의 번호를 가지고 있으며, 주사위에 쓰인 수의 구성은 모두 다릅니다.\n\nA가 먼저 n / 2개의 주사위를 가져가면 B가 남은 n / 2개의 주사위를 가져갑니다. 각각 가져간 주사위를 모두 굴린 뒤, 나온 수들을 모두 합해 점수를 계산합니다. 점수가 더 큰 쪽이 승리하며, 점수가 같다면 무승부입니다.\n\nA는 자신이 승리할 확률이 가장 높아지도록 주사위를 가져가려 합니다.\n\n다음은 n = 4인 예시입니다.\n\n주사위\t구성  \n\n- 1:\t[1, 2, 3, 4, 5, 6]  \n- 2:\t[3, 3, 3, 3, 4, 4]  \n- 3:\t[1, 3, 3, 4, 4, 4]  \n- 4:\t[1, 1, 4, 4, 5, 5]    \n\n예를 들어 A가 주사위 #1, #2를 가져간 뒤 6, 3을 굴리고, B가 주사위 #3, #4를 가져간 뒤 4, 1을 굴린다면 A의 승리입니다. (6 + 3 > 4 + 1)  \nA가 가져가는 주사위 조합에 따라, 주사위를 굴린 1296가지 경우의 승패 결과를 세어보면 아래 표와 같습니다.\n\n| A의 주사위 |\t승 |\t무 |\t패 |  \n| --- | --- | --- | --- |\n| #1, #2 |\t596 |\t196 |\t504 |\n|#1, #3 |\t560 |\t176 |\t560 |\n|#1, #4 |\t616 |\t184 |\t496 |\n|#2, #3 |\t496 |\t184 |\t616 |\n|#2, #4 |\t560 |\t176 |\t560 |\n|#3, #4 |\t504 |\t196 |\t596 |\n\nA가 승리할 확률이 가장 높아지기 위해선 주사위 #1, #4를 가져가야 합니다.\n\n주사위에 쓰인 수의 구성을 담은 2차원 정수 배열 dice가 매개변수로 주어집니다. 이때, 자신이 승리할 확률이 가장 높아지기 위해 A가 골라야 하는 주사위 번호를 오름차순으로 1차원 정수 배열에 담아 return 하도록 solution 함수를 완성해 주세요. 승리할 확률이 가장 높은 주사위 조합이 유일한 경우만 주어집니다.\n\n## 제한사항\n- 2 ≤ dice의 길이 = n ≤ 10  \n- n은 2의 배수입니다.  \n- dice[i]는 i+1번 주사위에 쓰인 6개의 수를 담고 있습니다.  \n- dice[i]의 길이 = 6  \n- 1 ≤ dice[i]의 원소 ≤ 100\n\n## 입출력 예\n| dice | result |\n| --- | --- |\n| [[1, 2, 3, 4, 5, 6], [3, 3, 3, 3, 4, 4], [1, 3, 3, 4, 4, 4], [1, 1, 4, 4, 5, 5]]|[1, 4] |\n| [[1, 2, 3, 4, 5, 6], [2, 2, 4, 4, 6, 6]]|[2] |\n| [[40, 41, 42, 43, 44, 45], [43, 43, 42, 42, 41, 41], [1, 1, 80, 80, 80, 80], [70, 70, 1, 1, 70, 70]]|[1, 3] |\n\n## 입출력 예 설명\n\n### 입출력 예 #1\n\n문제 예시와 같습니다.\n\n### 입출력 예 #2\n\n주사위 구성  \n- 1:\t[1, 2, 3, 4, 5, 6]  \n- 2:\t[2, 2, 4, 4, 6, 6]  \n\nA가 주사위 #2를 가져갔을 때 승리할 확률이 가장 높습니다. A가 #2, B가 #1 주사위를 굴린 결과에 따른 승패는 아래 표와 같습니다.\n\n| 주사위 결과 |\t1 (B)|2 (B)|3 (B)|4 (B)|5 (B)|6 (B)|\n| --- | --- | --- | --- | --- | --- | --- |\n|2 (A)|\t승|\t무|\t패|\t패|\t패|\t패|\n|2 (A)| 승| 무| 패| 패| 패| 패|\n|4 (A)|\t승|\t승|\t승|\t무|\t패|\t패|\n|4 (A)|\t승|\t승|\t승|\t무|\t패|\t패|\n|6 (A)|\t승|\t승|\t승|\t승|\t승|\t무|\n|6 (A)|\t승|\t승|\t승|\t승|\t승|\t무|\n\n### 입출력 예 #3\n\n주사위 구성  \n- 1:  [40, 41, 42, 43, 44, 45]  \n- 2:  [43, 43, 42, 42, 41, 41]  \n- 3:  [1, 1, 80, 80, 80, 80]  \n- 4:  [70, 70, 1, 1, 70, 70]  \n\nA가 가져가는 주사위 조합에 따라, 주사위를 굴린 1296가지 경우의 승패 결과를 세어보면 아래 표와 같습니다.\n\n| A의 주사위 | 승  | 무  | 패  |\n|------------|-----|-----|-----|\n| #1, #2     | 704 | 16  | 576 |\n| #1, #3     | 936 | 24  | 336 |\n| #1, #4     | 360 | 24  | 912 |\n| #2, #3     | 912 | 24  | 360 |\n| #2, #4     | 336 | 24  | 936 |\n| #3, #4     | 576 | 16  | 704 |\n\n따라서 A가 주사위 #1, #3을 가져갔을 때 승리할 확률이 가장 높습니다.\n\n# 문제 풀이\n\n조합과 시뮬레이션으로 접근하였고, 최대 연산 수가 약 150억(10C5 x 6^5 x 6^5)이 나와 최적화해야겠다고 생각했다.\n\n먼저 A가 굴릴 주사위를 재귀로 선택했다.\n\n나머지는 B의 주사위가 된다.\n\nA와 B가 굴리는 모든 경우를 센다.\n\n여기서 핵심은 중복 경우를 제거하는 것인데, 단순히 같은 주사위 조합일 경우 뿐만 아니라, 주사위의 조합이 다르더라도 주사위의 합이 같은 경우도 중복된 경우였다. (결과에는 반영해야하니 count를 1 더한다.) 결국 A와 B의 주사위의 합으로 비교를 하기 때문이다. => 주사위의 합으로 승패를 가린다는 내용을 문제에서 봤을 때 힌트가 될 거라고 느낄만 한 부분인 것 같다.\n\n하지만 만약 주사위의 합이 모두 다르다면 똑같이 150억 연산을 할 것이다.\n\n그래서 무조건 최악의 경우가 10억 이내에 들어야한다는 생각으로 풀기보다, 최선의 알고리즘을 찾는다는 생각으로 푸는 것이 맞지 않나 싶은데, 그러자니 확신 없이 풀어야한다는 단점도 있는 것 같다.\n\n결국 문제 유형을 잘 이해하고 주어진 시간 내에 최선의 알고리즘을 찾아야하는 것 같다. (당연한 말)\n\n\n# 코드\n\n```javascript\nfunction solution(dice) {\n    var answer = [];\n    let maxWins = 0\n    \n    pickDices(pick, [], -1)\n    \n    // 252\n    function pickDices(callback, currentDices, flag){\n        if(currentDices.length == dice.length/2){\n            return callback(currentDices)\n        }\n        for(let i=flag+1; i<dice.length; i++){\n            pickDices(callback, [...currentDices, i], i)\n        }\n    }\n    \n    function pick(dicesA){\n        let winCount = 0\n        let loseCount = 0\n        \n        // A has dicesA.\n        // B has rest of it.\n        const dicesB = []\n        for(let i=0; i<dice.length; i++){\n            if(dicesA.indexOf(i)!=-1) {\n                continue\n            }\n            dicesB.push(i)\n        }\n        \n        // roll\n        const eyesA = getSumCounts(dicesA)\n        const eyesB = getSumCounts(dicesB)\n        \n        eyesA.forEach((Acount, Asum)=>{\n            eyesB.forEach((Bcount, Bsum)=>{\n                if(Asum>Bsum){\n                    winCount += Acount * Bcount\n                    if(winCount > maxWins){\n                        maxWins = winCount\n                        answer = dicesA.map(v=>v+1)\n                    }\n                } else{\n                    loseCount += Acount * Bcount\n                }\n            })\n        })\n    }\n    \n    function getSumCounts(dices){\n        const sumCounts = new Map()\n        rollDice(0, dices, 0, sumCounts)\n        return sumCounts\n    }\n    \n    function rollDice(currentSum, dices, index, sumCounts){\n        if(index==dices.length){\n            if(!sumCounts.has(currentSum))\n                sumCounts.set(currentSum, 0)\n            return sumCounts.set(currentSum, sumCounts.get(currentSum)+1)\n        }\n        for(let i=0; i<6; i++){\n            rollDice(currentSum + dice[dices[index]][i], dices, index+1, sumCounts)\n        }\n    }\n    \n    return answer;\n}\n\n// 6C2 x 4C2 x 36 x 36\n// 15 x 6 x 36 x 36 =~ 120000\n\n// 10C5 x 6^5 x 6^5 =~ 150억\n```",
    "tags": [
      "javascript",
      "조합",
      "중복_제거"
    ],
    "date_started": "2025.09.15",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/algorithm/%EC%A3%BC%EC%82%AC%EC%9C%84_%EA%B3%A0%EB%A5%B4%EA%B8%B0.md",
    "preview": ""
  },
  {
    "id": "posts/study/react_js_recap.md",
    "category": "Study",
    "title": "실용 React, JS 메모",
    "content": "\n![dependency tree](https://github.com/user-attachments/assets/5d99aa13-5d32-4ad2-9902-0bdd7427845e)\n\nReact.dev를 정독하며, React 프로젝트에 바로 적용할 만한 내용들과 더 나은 프로젝트를 위해 이해해야하는 개념을 메모함.\n\n개념이나 기능이 좋으면 메모한다기 보다는, *프로젝트를 진행하면서 이런 개념 혹은 기능이 필요했는데, 이런 식으로 풀이하는구나.* 하는 부분을 적음. *(바로 적용할 만한 내용)*.\n\n혹은 *이건 꼭 이해하고 있어야겠다*. 하는 내용을 적음\n\n# React\n\n### Props\n컴포넌트의 Props는 읽기 전용 스냅샷으로, ***렌더링 할 때마다 새로운 버전의 props***를 받습니다.\n\n### Fragment (<></>의 명시적 문법)\n각 항목이 하나가 아닌 여러 개의 DOM 노드를 렌더링해야 하는 경우에는 어떻게 해야 할까요?\n\n짧은 <> </> fragment 구문으로는 key를 전달할 수 없으므로 key를 단일 <div>로 그룹화하거나 약간 더 길고 명시적인 <Fragment> 문법을 사용해야 합니다.\n\n```jsx\n\nimport { Fragment } from 'react';\n\n// ...\n\nconst listItems = people.map(person =>\n <Fragment key={person.id}>\n   <h1>{person.name}</h1>\n   <p>{person.bio}</p>\n </Fragment>\n);\n```\n\nFragment는 DOM에서 사라지므로 `<h1>, <p>, <h1>, <p>`등의 평평한 리스트가 생성됩니다.\n\n### 배열 랜더링에서 key\n\n*주의하세요!*\n\n배열에서 항목의 인덱스를 key로 사용하고 싶을 수도 있습니다. **실제로 key를 전혀 지정하지 않으면 React는 인덱스를 사용합니다.**\n\n하지만 항목이 삽입되거나 삭제하거나 배열의 순서가 바뀌면 시간이 지남에 따라 항목을 렌더링하는 순서가 변경됩니다. 인덱스를 key로 사용하면 종종 미묘하고 혼란스러운 버그가 발생합니다.\n\n마찬가지로 key={Math.random()}처럼 즉석에서 key를 생성하지 마세요. 이렇게 하면 렌더링 간에 key가 일치하지 않아 모든 컴포넌트와 DOM이 ***매번 다시 생성될 수 있습니다***. 속도가 느려질 뿐만 아니라 리스트 항목 내부의 모든 사용자의 입력도 손실됩니다. 대신 데이터 기반의 안정적인 ID를 사용하세요.\n\n\n### 의존성 트리\n\n![dependency tree](https://github.com/user-attachments/assets/5d99aa13-5d32-4ad2-9902-0bdd7427845e)\n\n앱이 커짐에 따라 번들 크기도 커집니다. 번들 크기가 커지면 클라이언트가 다운로드하고 실행하는 데 드는 비용도 커집니다. 또한 UI가 그려지는 데 시간이 지체될 수 있습니다. 앱의 의존성 트리를 파악하면 이러한 문제를 디버깅하는 데 도움이 될 수 있습니다.\n\n### State Queue\n\n***React는 이벤트 핸들러가 실행을 마친 후 state 업데이트를 처리합니다. 이를 batching 이라고 합니다.***\n\n이벤트 핸들러가 완료되면 React는 리렌더링을 실행합니다. 리렌더링하는 동안 React는 큐를 처리합니다. 업데이터 함수는 렌더링 중에 실행되므로, 업데이터 함수는 순수해야 하며 결과만 반환 해야 합니다.\n\n업데이터 함수 내부에서 state를 변경하거나 다른 사이드 이팩트를 실행하려고 하지 마세요. Strict 모드에서 React는 각 업데이터 함수를 두 번 실행(두 번째 결과는 버림)하여 실수를 찾을 수 있도록 도와줍니다.\n\n### Event handler\n\n*중요합니다!*\n\n이벤트 핸들러에 적절한 HTML 태그를 사용하고 있는지 확인하세요. 예를 들어 클릭을 처리하기 위해서는 `<div onClick={handleClick}>` 대신 `<button onClick={handleClick}>`을 사용하세요.\n\n실제 브라우저에서 `<button>`은 키보드 내비게이션과 같은 빌트인 브라우저 동작을 활성화 합니다. 만일 버튼의 기본 브라우저 스타일링이 싫어서 링크나 다른 UI 요소처럼 보이도록 하고 싶다면 CSS를 통해 그 목적을 이룰 수 있습니다. \n\n### Propagation\n\n부여된 JSX 태그 내에서만 실행되는 `onScroll`을 제외한 React 내의 모든 이벤트는 전파됩니다.\n\n- 드물게 전파가 중단된 상황일지라도 자식 컴포넌트의 모든 이벤트를 캡처해 확인해야 할 수 있습니다. 일례로, 분석을 위해 전파 로직에 상관 없이 모든 클릭 이벤트를 기록하고 싶을 수 있습니다. 이를 위해서는 이벤트명 마지막에 Capture를 추가하면 됩니다.\n  ``` jsx\n  <div onClickCapture={() => { /* this runs first */ }}>\n    <button onClick={e => e.stopPropagation()} />\n    <button onClick={e => e.stopPropagation()} />\n  </div>\n  ```\n  각각의 이벤트는 세 단계를 거쳐 전파됩니다.\n\n  - 아래로 전달되면서 만나는 모든 onClickCapture 핸들러를 호출합니다.\n  - 클릭된 요소의 onClick 핸들러를 실행합니다.\n  - 위로 전달되면서 만나는 모든 onClick 핸들러를 호출합니다.\n  - 이벤트 캡처는 라우터나 분석을 위한 코드에 유용할 수 있지만 일반 애플리케이션 코드에서는 사용하지 않을 가능성이 높습니다.\n\n### useReducer\n\n[State 로직을 reducer로 작성하기](https://ko.react.dev/learn/extracting-state-logic-into-a-reducer)\n\n여러 이벤트 핸들러를 통해 많은 state 업데이트가 이루어지는 컴포넌트는 감당하기 힘들 수 있습니다. 이 때 컴포넌트 외부에서 “reducer”라는 단일 함수를 사용하여 모든 state 업데이트 로직을 통합할 수 있습니다. 이벤트 핸들러는 오로지 사용자의 “action”만을 명시하므로 간결해집니다.\n\n각 action에 대한 state 업데이트 방법은 파일 맨 마지막 부분의 reducer 함수에 명시되어 있습니다.\n\n### [Reducer와 Context로 앱 확장하기](https://ko.react.dev/learn/scaling-up-with-reducer-and-context)\nReducer를 사용하면 컴포넌트의 state 업데이트 로직을 통합할 수 있습니다. Context를 사용하면 다른 컴포넌트에 정보를 깊숙이 전달할 수 있습니다. Reducer와 Context를 함께 사용하여 복잡한 화면의 state를 관리할 수 있습니다.\n\n이 접근 방식을 사용하면 상위 컴포넌트가 Reducer로 복잡한 state를 관리합니다. 트리 깊은 곳에 있는 다른 컴포넌트는 Context를 통해 상위 컴포넌트의 state를 읽을 수 있습니다. 또한 해당 state를 업데이트하기 위해 action을 dispatch 할 수도 있습니다.\n\n## [Escape-Hatches](https://ko.react.dev/learn/escape-hatches)\n\n### useMemo()\n계산이 비싼지 어떻게 알 수 있나요? \n\n일반적으로 수천 개의 객체를 만들거나 반복하는 경우가 아니라면 비용이 많이 들지 않을 것입니다. 좀 더 확신을 얻고 싶다면 console log를 추가하여 코드에 소요된 시간을 측정할 수 있습니다.\n\n```js\nconsole.time('filter array');\nconst visibleTodos = getFilteredTodos(todos, filter);\nconsole.timeEnd('filter array');\n```\n\n측정하려는 상호작용을 수행합니다(예: input에 입력하기). 그러면 filter array: 0.15ms와 같은 로그가 console에 표시됩니다. 전체적으로 기록된 시간이 상당한 양(예: 1ms 이상)으로 합산되면 해당 계산을 메모이제이션하는 것이 좋습니다. 그런 다음 실험적으로 해당 계산을 useMemo로 감싸서 해당 상호작용에 대해 총 로깅 시간이 감소했는지를 확인할 수 있습니다.\n\n```js\nconsole.time('filter array');\nconst visibleTodos = useMemo(() => {\n  return getFilteredTodos(todos, filter); // todos와 filter가 변경되지 않은 경우 건너뜁니다\n}, [todos, filter]);\nconsole.timeEnd('filter array');\n```\nuseMemo는 첫 번째 렌더링을 더 빠르게 만들지 않습니다. 업데이트 시 불필요한 작업을 건너뛰는 데만 도움이 됩니다.\n\n당신의 컴퓨터가 사용자의 컴퓨터보다 빠를 수 있으므로 인위적인 속도 저하로 성능을 테스트하는 것이 좋습니다. 예를 들어 Chrome은 이를 위해 CPU 스로틀링 옵션을 제공합니다.\n\n또한 개발 중에 성능을 측정하는 것은 가장 정확한 결과를 제공하지 않는다는 점에 유의하세요. (예를 들어 Strict Mode를 켜면 각 컴포넌트가 한 번이 아닌 두 번 렌더링 되는 것을 볼 수 있습니다.) 가장 정확한 시간을 얻으려면 프로덕션용 앱을 빌드하고 사용자가 사용하는 것과 같은 기기에서 테스트하세요.\n\n### key를 통한 state 초기화\n\nprop 변경 시 모든 state 초기화 \n\n이 ProfilePage 컴포넌트는 userId prop을 받습니다. 페이지는 댓글 입력을 포함하며 comment state 변수를 사용해 해당 값을 보관합니다. 어느 날 한 프로필에서 다른 프로필로 이동할 때 comment state가 재설정되지 않는 문제를 발견했습니다. 그 결과 실수로 잘못된 사용자의 프로필에 댓글을 게시하기 쉽습니다. 이 문제를 해결하기 위해 userId가 변경될 때마다 comment state 변수를 비우려고 합니다.\n\n```jsx\nexport default function ProfilePage({ userId }) {\n  const [comment, setComment] = useState('');\n\n  // 🔴 피하세요: Effect에서 prop 변경 시 state 초기화\n  useEffect(() => {\n    setComment('');\n  }, [userId]);\n  // ...\n}\n```\n\n이는 비효율적인데 ProfilePage와 그 자식이 오래된 값으로 처음 렌더링 한 다음 다시 렌더링 하기 때문입니다. 또한 ProfilePage 내부에 어떤 state가 있는 모든 컴포넌트에서 이 작업을 수행해야 하므로 복잡합니다. 예를 들어 댓글 UI가 중첩된 경우 중첩된 댓글 state도 비워야 합니다.\n\n대신 명시적인 key를 전달하여 각 사용자의 프로필이 개념적으로 다른 프로필임을 React에 알릴 수 있습니다. 컴포넌트를 둘로 분할하고 외부 컴포넌트에서 내부 컴포넌트로 key 어트리뷰트를 전달하세요.\n\n```jsx\nexport default function ProfilePage({ userId }) {\n  return (\n    <Profile\n      userId={userId}\n      key={userId}\n    />\n  );\n}\n\nfunction Profile({ userId }) {\n  // ✅ 이 state 및 아래의 다른 state는 key 변경 시 자동으로 재설정됩니다.\n  const [comment, setComment] = useState('');\n  // ...\n}\n```\n일반적으로 React는 동일한 컴포넌트가 같은 위치에 렌더링 될 때 state를 보존합니다. Profile 컴포넌트에 userId를 key로 전달하면 React가 userId가 다른 두 개의 Profile 컴포넌트를 state를 공유해서는 안 되는 두 개의 다른 컴포넌트로 취급하도록 요청하는 것입니다. userId로 설정한 key가 변경될 때마다 React는 DOM을 다시 생성하고 Profile 컴포넌트와 그 모든 자식의 state를 재설정합니다. 이제 프로필 사이를 탐색할 때 comment 필드가 자동으로 비워집니다.\n\n이 예시에서는 외부 ProfilePage 컴포넌트만 내보내 프로젝트의 다른 파일에 표시된다는 점에 유의하세요. ProfilePage를 렌더링하는 컴포넌트는 key를 전달할 필요 없이 일반적인 prop로 userId를 전달합니다. ProfilePage가 이를 내부 Profile 컴포넌트에 key로 전달한다는 사실은 구현 세부 사항입니다.\n\n### 연쇄 계산 \n\n때때로 다른 state에 따라 각각 state를 조정하는 Effect를 체이닝하고 싶을 때가 있습니다.\n```jsx\nfunction Game() {\n  const [card, setCard] = useState(null);\n  const [goldCardCount, setGoldCardCount] = useState(0);\n  const [round, setRound] = useState(1);\n  const [isGameOver, setIsGameOver] = useState(false);\n\n  // 🔴 피하세요: 서로를 트리거하기 위해서만 state를 조정하는 Effect 체인\n  useEffect(() => {\n    if (card !== null && card.gold) {\n      setGoldCardCount(c => c + 1);\n    }\n  }, [card]);\n\n  useEffect(() => {\n    if (goldCardCount > 3) {\n      setRound(r => r + 1)\n      setGoldCardCount(0);\n    }\n  }, [goldCardCount]);\n\n  useEffect(() => {\n    if (round > 5) {\n      setIsGameOver(true);\n    }\n  }, [round]);\n\n  useEffect(() => {\n    alert('Good game!');\n  }, [isGameOver]);\n\n  function handlePlaceCard(nextCard) {\n    if (isGameOver) {\n      throw Error('Game already ended.');\n    } else {\n      setCard(nextCard);\n    }\n  }\n\n  // ...\n```\n이 코드에는 두 가지 문제가 있습니다.\n\n첫 번째 문제는 매우 비효율적이라는 점입니다. 컴포넌트(및 그 자식)는 체인의 각 set 호출 사이에 다시 렌더링해야 합니다. 위의 예시에서 최악의 경우(setCard → 렌더링 → setGoldCardCount → 렌더링 → setRound → 렌더링 → setIsGameOver → 렌더링)에는 아래 트리의 불필요한 리렌더링이 세 번 발생합니다.\n\n두 번째 문제는 속도가 느리지 않더라도 코드가 발전함에 따라 작성한 “체인”이 새로운 요구 사항에 맞지 않는 경우가 발생할 수 있다는 점입니다. 게임 이동의 기록을 단계별로 살펴볼 수 있는 방법을 추가한다고 가정해 보겠습니다. 각 state 변수를 과거의 값으로 업데이트하여 이를 수행할 수 있습니다. 하지만 card state를 과거의 값으로 설정하면 Effect 체인이 다시 트리거되고 표시되는 데이터가 변경됩니다. 이러한 코드는 융통성이 없고 취약한 경우가 많습니다.\n\n이 경우 렌더링 중에 가능한 것을 계산하고 이벤트 핸들러에서 state를 조정하는 것이 좋습니다.\n```jsx\nfunction Game() {\n  const [card, setCard] = useState(null);\n  const [goldCardCount, setGoldCardCount] = useState(0);\n  const [round, setRound] = useState(1);\n\n  // ✅ 렌더링 중에 가능한 것을 계산합니다.\n  const isGameOver = round > 5;\n\n  function handlePlaceCard(nextCard) {\n    if (isGameOver) {\n      throw Error('Game already ended.');\n    }\n\n    // ✅ 이벤트 핸들러에서 다음 state를 모두 계산합니다.\n    setCard(nextCard);\n    if (nextCard.gold) {\n      if (goldCardCount <= 3) {\n        setGoldCardCount(goldCardCount + 1);\n      } else {\n        setGoldCardCount(0);\n        setRound(round + 1);\n        if (round === 5) {\n          alert('Good game!');\n        }\n      }\n    }\n  }\n\n  // ...\n```\n훨씬 더 효율적입니다. 또한 게임 기록을 볼 수 있는 방법을 구현하면 이제 다른 모든 값을 조정하는 Effect 체인을 트리거 하지 않고도 각 state 변수를 과거의 행동으로 설정할 수 있습니다. 여러 이벤트 핸들러 간에 로직을 재사용해야 하는 경우 함수를 추출하여 해당 핸들러에서 호출할 수 있습니다.\n\n이벤트 핸들러 내부에서 state는 스냅샷처럼 동작한다는 점을 기억하세요. 예를 들어 `setRound(round + 1)`를 호출한 후에도 round 변수는 사용자가 버튼을 클릭한 시점의 값을 반영합니다. 계산에 다음 값을 사용해야 하는 경우 `const nextRound = round + 1`처럼 수동으로 정의하세요.\n\n이벤트 핸들러에서 직접 다음 state를 계산할 수 없는 경우도 있습니다. 예를 들어 여러 개의 드롭 다운이 있는 폼에서 다음 드롭 다운의 옵션이 이전 드롭 다운의 선택된 값에 따라 달라진다고 가정해 보겠습니다. 이 경우 네트워크와 동기화하기 때문에 Effect 체인이 적절합니다.\n\n### 애플리케이션 초기화 \n일부 로직은 앱이 로드될 때 한 번만 실행되어야 합니다.\n\n그것을 최상위 컴포넌트의 Effect에 배치하고 싶을 수도 있습니다.\n```jsx\nfunction App() {\n  // 🔴 피하세요: 한 번만 실행되어야 하는 로직이 포함된 Effect\n  useEffect(() => {\n    loadDataFromLocalStorage();\n    checkAuthToken();\n  }, []);\n  // ...\n}\n```\n하지만 이 함수가 개발 중에 두 번 실행된다는 사실을 금방 알게 될 것입니다. 함수가 두 번 호출되도록 설계되지 않았기 때문에 인증 토큰이 무효화되는 등의 문제가 발생할 수 있습니다. 일반적으로 컴포넌트는 다시 마운트 할 때 탄력이 있어야 합니다. 여기에는 최상위 App 컴포넌트가 포함됩니다.\n\n프로덕션 환경에서 실제로 다시 마운트되지 않을 수도 있지만 모든 컴포넌트에서 동일한 제약 조건을 따르면 코드를 이동하고 재사용하기가 더 쉬워집니다. 일부 로직이 컴포넌트 마운트당 한 번이 아니라 앱 로드당 한 번 실행되어야 하는 경우 최상위 변수를 추가하여 이미 실행되었는지를 추적하세요.\n\n```jsx\nlet didInit = false;\n\nfunction App() {\n  useEffect(() => {\n    if (!didInit) {\n      didInit = true;\n      // ✅ 앱 로드당 한 번만 실행\n      loadDataFromLocalStorage();\n      checkAuthToken();\n    }\n  }, []);\n  // ...\n}\n모듈 초기화 중이나 앱이 렌더링 되기 전에 실행할 수도 있습니다.\n\nif (typeof window !== 'undefined') { // 브라우저에서 실행 중인지 확인합니다.\n   // ✅ 앱 로드당 한 번만 실행\n  checkAuthToken();\n  loadDataFromLocalStorage();\n}\n\nfunction App() {\n  // ...\n}\n```\n컴포넌트를 import 할 때 최상위 레벨의 코드는 렌더링 되지 않더라도 한 번 실행됩니다. 임의의 컴포넌트를 import 할 때 속도 저하나 예상치 못한 동작을 방지하려면 이 패턴을 과도하게 사용하지 마세요. app 전체 초기화 로직은 App.js와 같은 루트 컴포넌트 모듈이나 애플리케이션의 엔트리 포인트에 두세요.\n\n# Javascript\n\n### Hoisting\n- var, let, const 모두 호이스팅되나, var만 undefined로 초기화된다. 나머지는 초기화되지 않으므로, initialization 전에 참조할 수 없다는 `Reference Error`가 발생한다.\n- function은 선언 뿐만 아니라 정의도 맨 위로 올라간다.\n- const fn = ()=>{} 문법은 const와 동일하게 작동한다.\n\n### Array.filter(fn)\n- fn이 true를 리턴하는 원소만 모은 배열을 리턴한다.\n\n### Array.from(iterable || array-like object, mapFunction)\n\n```js\nconsole.log(Array.from(\"foo\"));\n// Expected output: Array [\"f\", \"o\", \"o\"]\n\nconsole.log(Array.from([1, 2, 3], (x) => x + x));\n// Expected output: Array [2, 4, 6]\n```\n\n# 참고자료\n- [React.dev](https://ko.react.dev/learn)",
    "tags": [
      "javascript",
      "react"
    ],
    "date_started": "2025.08.13",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/study/react_js_recap.md",
    "preview": ""
  },
  {
    "id": "posts/study/javascript.md",
    "category": "Study",
    "title": "Javascript, Under the Hood",
    "content": "\n> Javascript의 내부 동작 방식을 정리했다.\n\n# JIT (Just In Time) 컴파일러\nJavascript는 JIT(Just In Time) 방식으로 코드를 컴파일하고 실행한다. JIT는 런타임에 코드를 컴파일한다는 의미이며, 코드를 파싱한 후 인터프리터 + 최적화가 더해진 과정이다. JIT 컴파일러는 코드를 실행하기 전에 최적화하여 성능을 향상시키며 프로그램의 적응력을 높인다.\n\n컴파일 방식에 관해서는 컴파일러 + 인터프리터 + 최적화라고 이해하고 넘어갔다. (2025.06.23: 메모리 및 동작 환경을 이해하는 목적이므로)\n\n![Image](https://github.com/user-attachments/assets/e0b597ae-ae1b-4ad8-b8c7-d7cd593d7be3)\n\n# Javascript, Under the Hood\n\n> Javascript runtime을 이해하는 데에 많은 도움이 되는 영상 [Scotland JS](https://vimeo.com/96425312)\n\n## Javascript / Javascript runtime\nJavascript는 프로그래밍 언어로, 웹 브라우저에서 실행되는 스크립트 언어이다. Javascript runtime은 Javascript 코드를 실행하는 환경을 의미한다. 대표적인 Javascript runtime으로는 웹 브라우저가 있다.\n\nJavascript는 Heap과 Call Stack을 사용하여 메모리를 관리한다.\n\n\n## Call Stack\nCall Stack은 함수 호출을 관리하고 원시 타입을 저장하는 곳이다. 함수가 호출될 때마다 스택에 쌓이고, 함수 실행이 끝나면 스택에서 제거된다. Call Stack은 LIFO(Last In First Out) 구조로 동작한다.\n\n\n## Heap\nHeap은 객체를 저장하는 곳이다. Call Stack과 달리 객체는 참조 타입으로 저장되며, 메모리 할당과 해제를 자동으로 관리한다(gc).\n\n여기까지는 Javascript에서 기본적으로 사용하는 메모리 구조이다. 이제 Javascript runtime에서 Web API와 이벤트 루프, 태스크 큐를 살펴보자.\n\n## Web API\nWeb API는 브라우저에서 제공하는 API로, 비동기 작업을 처리할 수 있게 해준다. 예를 들어, setTimeout, fetch, DOM 이벤트 등이 있다. Web API는 Call Stack과 별도로 실행되며, 비동기 작업이 완료되면 Task Queue에 작업을 추가한다.\n\n## Task Queue\nTask Queue는 Web API에서 비동기 작업이 완료되었을 때, 해당 작업을 Call Stack으로 가져오기 위해 대기하는 큐이다. Task Queue에 있는 작업은 Call Stack이 비어있을 때 Event Loop에 의해 실행된다. (Call Stack으로 옮겨진다.) Task Queue는 FIFO(First In First Out) 구조로 동작한다.\n\n## Event Loop\nEvent Loop는 Call Stack과 Task Queue를 연결하는 역할을 한다. Call Stack이 비어있을 때, Task Queue에 있는 작업을 Call Stack으로 가져와 실행한다. 이를 통해 비동기 작업을 처리할 수 있다.\n\n이를 도식화하면 아래와 같다.\n\n![Image](https://github.com/user-attachments/assets/d91142a0-fb35-453c-88ea-de490b67d0b4)",
    "tags": [
      "call-stack",
      "event-loop",
      "javascript",
      "task-queue",
      "web-api"
    ],
    "date_started": "2025.06.23",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/study/javascript.md",
    "preview": ""
  },
  {
    "id": "posts/algorithm/숫자카드.md",
    "category": "Algorithm",
    "title": "숫자카드",
    "content": "\n## 정렬\n\n---\n\n### Code\n\n<!-- CODE-APPENDED:4834_숫자카드.py -->\n```python\n\"\"\"\n\n\t4834_숫자카드 created at 2024-07-07-11:20:18\n    가장 많은 숫자와 장수\n    N <= 100\n\n    소요시간 5분\n    \n\"\"\"\n\nimport sys\nsys.stdin = open(\"input.txt\", \"r\")\n\nfor test_case in range(1, int(input()) + 1):\n    N = int(input())\n    cards = list(map(int, input()))\n    card_amount = [cards.count(i) for i in range(10)]\n    card_amount.reverse()\n    max_amount = 0\n    max_num = 9\n    for i in range(10):\n        if card_amount[i] > max_amount:\n            max_num = 9-i\n            max_amount = card_amount[i]\n    print(f'#{test_case} {max_num} {max_amount}')\n```\n",
    "tags": [
      "python",
      "정렬"
    ],
    "date_started": "2024.7.7",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/algorithm/%EC%88%AB%EC%9E%90%EC%B9%B4%EB%93%9C.md",
    "preview": ""
  },
  {
    "id": "posts/algorithm/구간합.md",
    "category": "Algorithm",
    "title": "구간합",
    "content": "\n## 구간합\n\n---\n\n### Code\n\n<!-- CODE-APPENDED:4835_구간합.py -->\n```python\n\"\"\"\n\n\t4835_구간합 created at 2024-07-07-11:25:09\n    소요시간 5분\n    \n\"\"\"\n\nimport sys\nsys.stdin = open(\"input.txt\", \"r\")\n\nfor test_case in range(1, int(input()) + 1):\n    N, M = map(int, input().split())\n    nums = list(map(int, input().split()))\n    sums = []\n    for i in range(N-(M-1)):\n        tmp_sum = 0\n        for j in range(M): # 이거 빼고 그냥 합 구해서 index M 차이나게 빼면 M배 빨라질 것.\n            tmp_sum += nums[i+j]\n        sums.append(tmp_sum)\n    print(f'#{test_case} {max(sums) - min(sums)}')\n```\n",
    "tags": [
      "python",
      "구간합"
    ],
    "date_started": "2024.7.7",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/algorithm/%EA%B5%AC%EA%B0%84%ED%95%A9.md",
    "preview": ""
  },
  {
    "id": "posts/study/react-query.md",
    "category": "Study",
    "title": "react-query",
    "content": "\n<img src=\"https://github.com/user-attachments/assets/f20fe75b-d444-4054-97ba-f6380e84f03d\" alt='react-query' />\n\n# React Query (TanStack Query v5)란 무엇인가?\n\n**React Query**, 현재는 **TanStack Query**로 알려져 있으며, TypeScript와 JavaScript 기반의 여러 프레임워크(React, Solid, Vue, Svelte, Angular)에서 사용할 수 있는 **강력한 비동기 상태 관리 라이브러리**입니다. 주로 서버 데이터를 효율적으로 관리하고, 클라이언트 애플리케이션의 상태를 간소화하는 데 사용됩니다.  \n\n---\n\n## **React Query의 핵심 기능과 특징**\n\n### 1. **선언적이고 자동화된 데이터 관리**\n- 데이터 페칭, 캐싱, 백그라운드 업데이트, 그리고 오래된 데이터 관리(**stale data**)를 자동으로 처리.\n- 개발자가 \"데이터를 어디서 가져올지\"와 \"어느 정도 신선해야 하는지\"만 정의하면 나머지 과정을 자동화.\n- 코드의 복잡성을 줄이고, 직관적인 데이터 흐름을 제공.\n\n### 2. **간단하고 익숙한 사용법**\n- **Promises**나 **async/await**를 이해하고 있다면, React Query 사용은 매우 직관적.\n- **전역 상태 관리**(Global State), **리듀서**(Reducer), **데이터 정규화 시스템**(Normalization System) 같은 복잡한 설정 불필요.\n- 데이터를 반환하거나 에러를 던지는 간단한 함수만 작성하면 나머지는 자동으로 처리.\n\n### 3. **확장 가능성**\n- 쿼리의 각 옵저버(Observer) 인스턴스에 대해 세부적으로 설정 가능.\n- **무한 스크롤**, **페이징**, **종속적 쿼리**(Dependent Query), **병렬 쿼리**, **변이(Mutation) API** 등 다양한 기능 제공.\n- 개발자 도구(Devtools)를 통해 쿼리 상태를 쉽게 확인 및 디버깅 가능.\n\n### 4. **제로 의존성, 풍부한 기능**\n- 의존성이 없으면서도 풍부한 기능을 제공.\n- 소규모 프로젝트에서 대규모 엔터프라이즈 애플리케이션(예: Walmart와 같은 대형 플랫폼)까지 사용 가능.\n\n### 5. **백엔드 독립적**\n- 특정 백엔드 기술에 의존하지 않으며, 다양한 데이터 소스와 함께 사용 가능.\n\n---\n\n## **React Query의 주요 기능**\n\n| **기능**                        | **설명**                                                                 |\n|--------------------------------|-------------------------------------------------------------------------|\n| **자동 캐싱**                   | 데이터를 자동으로 캐싱하여 동일한 요청의 중복 방지.                      |\n| **자동 리페치(Refetching)**     | 데이터가 오래되거나 상태가 변경되었을 때 자동으로 다시 가져오기.          |\n| **윈도우 포커스 리페치**         | 사용자가 브라우저 창으로 돌아오면 자동으로 데이터 업데이트.               |\n| **병렬 및 종속적 쿼리**          | 여러 데이터를 병렬로 가져오거나, 특정 데이터에 의존하는 쿼리 지원.        |\n| **무한 스크롤 및 페이징**         | 페이징 처리 및 무한 스크롤과 같은 대규모 데이터 처리.                     |\n| **오프라인 지원**               | 네트워크 연결이 없는 상태에서도 데이터 작업 가능.                         |\n| **SSR(Server-Side Rendering)** | 서버사이드 렌더링 지원으로 초기 로딩 성능 최적화.                        |\n| **변이 API(Mutation API)**       | 데이터 업데이트를 간단하고 효율적으로 처리.                             |\n| **요청 취소(Request Cancellation)** | 비효율적인 네트워크 요청을 취소 가능.                                    |\n\n---\n\n## **React Query와 Redux 비교**\n\n| **항목**               | **React Query**                             | **Redux**                            |\n|------------------------|---------------------------------------------|--------------------------------------|\n| **주요 목적**           | 서버 상태 관리                              | 클라이언트 상태 관리                 |\n| **설정**               | 최소 설정 필요                              | 초기 설정과 구조 설계가 필요          |\n| **데이터 페칭**         | 내장된 기능 제공 (자동화)                   | 별도의 Thunk/Saga 등의 설정 필요     |\n| **복잡성**             | 간단하고 직관적                             | 상대적으로 복잡                      |\n| **오프라인 지원**       | 기본 제공                                   | 직접 구현 필요                       |\n| **사용 사례**           | 서버 데이터 중심 애플리케이션                | 클라이언트 상태 관리가 주된 요구인 앱 |\n\n---\n\n## **React Query가 적합한 경우**\n- 데이터 페칭과 비동기 상태 관리를 효율적으로 처리해야 할 때.\n- 복잡한 서버 상태와 캐싱 로직이 필요한 애플리케이션.\n- API 호출 빈도가 많고, 실시간 데이터 동기화가 필요한 경우.\n\n## **Redux가 적합한 경우**\n- 애플리케이션에서 전역 클라이언트 상태 관리가 필요한 경우.\n- 서버 상태보다는 사용자 인터페이스(UI) 중심의 데이터 관리가 필요한 경우.\n\n---\n\n## **용어 설명**\n- **선언적(Declarative)**: \"어떻게\"가 아닌 \"무엇을\" 해야 하는지 명시하는 프로그래밍 방식.\n- **자동 캐싱(Auto Caching)**: 데이터를 임시로 저장하여 다시 요청하는 시간을 줄이는 기술.\n- **비동기 상태 관리(Asynchronous State Management)**: 네트워크 요청처럼 시간이 걸리는 작업의 상태를 추적하고 관리하는 것.\n- **변이(Mutation)**: 기존 데이터를 수정하거나 새 데이터를 추가하는 작업.\n- **종속적 쿼리(Dependent Query)**: 다른 데이터의 결과에 따라 실행되는 쿼리.\n\n---\n\n## **참고 자료**\n- [tanstack Query 공식 문서](https://tanstack.com/query/latest)",
    "tags": [
      "react",
      "redux",
      "state-management"
    ],
    "date_started": "2024.12.26",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/study/react-query.md",
    "preview": ""
  },
  {
    "id": "posts/study/firebase_firestore.md",
    "category": "Study",
    "title": "firebase_firestore",
    "content": "\n<img src='https://github.com/user-attachments/assets/618cf69a-3ddf-48bb-a2b5-286b847d2ac3' alt='firestore'/>\n\n\n\n> Spring 서버의 Mysql 데이터베이스를 Firebase Firestore로 마이그레이션하는 과정을 정리합니다.\n\n# Firestore란?\n\n**Firestore**는 Google Cloud Platform의 NoSQL 데이터베이스 서비스로, 실시간 데이터베이스와 클라우드 데이터베이스의 장점을 결합한 서비스입니다. Firestore는 데이터를 JSON 형식으로 저장하며, 실시간 업데이트와 오프라인 지원을 제공합니다.\n\n# Firestore vs MongoDB Atlas\n\n**Firestore**와 **MongoDB Atlas**는 모두 클라우드 기반의 NoSQL 데이터베이스 서비스입니다. 하지만 두 서비스는 설계 목표와 기능 면에서 차이가 있습니다. 이 문서에서는 주요 차이점과 장단점을 비교합니다.\n\n---\n\n## **Firestore 개요**\n- Google Firebase의 일부로, 모바일 및 웹 애플리케이션 개발에 최적화된 NoSQL 데이터베이스.\n- **문서(Document)** 및 **컬렉션(Collection)** 기반 계층적 데이터 구조 제공.\n- 실시간 동기화와 Firebase 인증, 호스팅 등의 서비스와 깊게 통합.\n\n---\n\n## **MongoDB Atlas 개요**\n- MongoDB의 클라우드 서비스로, 완전 관리형 NoSQL 데이터베이스.\n- JSON과 유사한 **BSON 형식**으로 데이터를 저장하며, 유연한 스키마 지원.\n- 대규모 트래픽 처리 및 복잡한 쿼리에 강점.\n\n---\n\n## **주요 비교**\n\n| **특징**                | **Firestore**                              | **MongoDB Atlas**                      |\n|-------------------------|--------------------------------------------|----------------------------------------|\n| **데이터 구조**          | 문서(Document)-컬렉션(Collection) 기반      | 문서(Document)-컬렉션(Collection) 기반  |\n| **스키마(Schema)**       | 스키마리스(Schema-less)                    | 스키마리스(Schema-less)                |\n| **실시간 동기화**        | 기본 제공                                 | 별도 설정 필요                        |\n| **쿼리(Query)**          | 제한된 복잡성(기본 제공 조건 쿼리 가능)      | 매우 유연하고 복잡한 쿼리 지원         |\n| **확장성(Scalability)**  | 자동 확장(수직 및 수평 확장 지원)           | 자동 확장(샤딩, 복제 지원)             |\n| **오프라인 지원**        | 기본 제공                                 | MongoDB Realm을 통해 일부 지원         |\n| **통합 서비스**          | Firebase 환경에 최적화된 서비스 제공         | 독립적 데이터베이스로 사용             |\n| **사용 사례**            | 실시간 애플리케이션(채팅, 협업 등)          | 대규모 데이터 저장 및 분석             |\n| **가격**                 | 단순한 종량제(Pay-as-you-go)               | 복잡한 종량제(Pay-as-you-go)           |\n\n---\n\n## **Firestore의 장단점**\n### 장점:\n1. **Firebase 통합**: 인증, 호스팅, 클라우드 함수 등과의 긴밀한 통합.\n2. **실시간 동기화**: 모바일 앱에 적합.\n3. **초보자 친화적**: 간단한 설정과 사용법.\n\n### 단점:\n1. **제한된 쿼리 기능**: 복잡한 데이터 처리에는 비효율적.\n2. **플랫폼 종속**: Firebase 환경에 종속적.\n\n---\n\n## **MongoDB Atlas의 장단점**\n### 장점:\n1. **유연성**: 복잡한 데이터 구조 및 쿼리에 강함.\n2. **대규모 확장성**: 샤딩(Sharding) 및 복제(Replication) 지원.\n3. **다양한 언어 지원**: 광범위한 프로그래밍 언어 및 플랫폼과 호환.\n\n### 단점:\n1. **실시간 동기화 부족**: 기본적으로 제공하지 않음.\n2. **복잡한 설정**: 초기 설정 및 관리가 Firestore에 비해 어렵다.\n\n---\n\n## **Firestore와 MongoDB Atlas는 언제 사용해야 할까?**\n- **Firestore가 적합한 경우**:\n  - 모바일/웹 앱 개발에서 실시간 데이터 동기화가 필요한 경우.\n  - Firebase 생태계에 의존하며 빠른 개발과 배포가 목표인 프로젝트.\n  \n- **MongoDB Atlas가 적합한 경우**:\n  - 대규모 데이터 처리 및 분석.\n  - 복잡한 쿼리와 유연한 데이터 모델이 필요한 경우.\n  - Firebase에 종속되지 않고 독립적으로 데이터베이스를 운영하려는 경우.\n\n---\n\n## **한국어 용어 설명**\n- **스키마리스(Schema-less)**: 데이터베이스에 미리 정의된 데이터 구조가 없어 유연하게 데이터 추가/변경 가능.\n- **샤딩(Sharding)**: 대규모 데이터를 여러 서버에 분산하여 저장하는 기술.\n- **복제(Replication)**: 데이터를 여러 복사본으로 저장해 고가용성을 보장하는 기술.\n- **실시간 동기화(Realtime Sync)**: 서버와 클라이언트 간 데이터를 즉시 일치시키는 기능.\n",
    "tags": [
      "cloud-service",
      "database",
      "firebase"
    ],
    "date_started": "2024.12.26",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/study/firebase_firestore.md",
    "preview": ""
  },
  {
    "id": "posts/study/firebase.md",
    "category": "Study",
    "title": "firebase",
    "content": "\n<img src='https://github.com/user-attachments/assets/8faf0ab9-0da6-418d-9812-e2b844b8aa3e' alt='firebase' width='640px' />\n\n# Firebase란 무엇인가? (AWS와 비교)\n\n**Firebase**는 Google에서 개발한 웹 및 모바일 애플리케이션 제작 플랫폼입니다. 주로 소규모 팀이나 프론트엔드 개발 중심의 프로젝트를 위해 설계된 도구와 서비스를 제공합니다. 다음은 Firebase와 AWS 같은 클라우드 서비스의 비교입니다.\n\n---\n\n## **Firebase 개요**\n- **백엔드 서비스(BaaS)**: Firebase는 백엔드 복잡성을 줄여주는 미리 만들어진 서비스를 제공합니다. 예: 인증, 데이터베이스, 호스팅 등.\n- **주요 기능**:\n  1. **실시간 데이터베이스 & Firestore**: 클라우드 기반 NoSQL 데이터베이스로, 실시간 또는 요청 시 동기화 가능.\n  2. **인증(Authentication)**: Google, Facebook, 이메일 등의 제공자로 사용자를 간편하게 로그인 처리.\n  3. **클라우드 함수(Cloud Functions)**: 이벤트(예: 데이터베이스 변경)에 의해 트리거되는 서버 측 로직 실행.\n  4. **호스팅(Hosting)**: 정적 파일 및 싱글 페이지 애플리케이션(SPA)을 위한 빠르고 안전한 웹 호스팅.\n  5. **분석 및 크래시 리포팅**: 사용자 행동 추적 및 디버깅을 위한 도구 제공.\n\n- **적합한 경우**: 소규모 및 중간 규모 앱, 프로토타입, 실시간 기능 또는 크로스 플랫폼(iOS + Android) 지원이 중요한 프로젝트.\n\n---\n\n## **AWS 개요**\n- **인프라 서비스(IaaS) + 플랫폼 서비스(PaaS)**: AWS는 컴퓨팅, 스토리지, 네트워크, AI/ML 등을 위한 광범위한 클라우드 서비스를 제공합니다.\n- **주요 기능**:\n  1. **컴퓨팅 서비스(예: EC2)**: 맞춤형 가상 서버 제공.\n  2. **스토리지(예: S3)**: 파일, 미디어, 백업을 위한 확장 가능한 객체 저장소.\n  3. **데이터베이스**: 관계형(RDS), NoSQL(DynamoDB), 데이터 웨어하우스(Redshift) 등 다양한 옵션 제공.\n  4. **Lambda**: 이벤트에 의해 트리거되는 서버리스 컴퓨팅 함수(Firebase Cloud Functions와 유사하지만 더 커스터마이징 가능).\n  5. **글로벌 인프라**: 전 세계 데이터 센터와 고급 네트워크 도구 제공.\n\n- **적합한 경우**: 대규모 애플리케이션, 엔터프라이즈 솔루션, 고급 커스터마이징 및 확장성이 필요한 프로젝트.\n\n---\n\n## **비교**\n| **항목**                 | **Firebase**                          | **AWS**                                     |\n|--------------------------|----------------------------------------|---------------------------------------------|\n| **사용 편의성**          | 초보자 친화적, 설정 간단              | 학습 곡선이 높음, 전문 지식 필요             |\n| **주요 대상**            | 모바일 & 웹 앱                        | 모든 유형의 애플리케이션                     |\n| **확장성(Scalability)**  | 확장 가능하지만 제한 있음             | 매우 확장 가능, 맞춤형 지원                  |\n| **가격**                 | 단순한 종량제, 무료 플랜 제공          | 복잡한 가격 모델                             |\n| **커뮤니티**             | 모바일/웹 개발자 중심 커뮤니티 강함   | 엔터프라이즈 및 클라우드 개발 중심 커뮤니티 |\n| **커스터마이징**         | 제한적(관리형 서비스)                  | 매우 커스터마이징 가능                       |\n\n---\n\n## **결론**\n- **Firebase**는 소규모에서 중간 규모 앱을 빠르게 개발하고 백엔드 복잡성을 최소화하고자 할 때 적합합니다.\n- **AWS**는 엔터프라이즈급 솔루션, 고급 커스터마이징이 필요하거나 대규모 복잡한 시스템을 구축할 때 적합합니다.\n",
    "tags": [
      "cloud-service",
      "firebase"
    ],
    "date_started": "2024.12.26",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/study/firebase.md",
    "preview": ""
  },
  {
    "id": "posts/study/turbopack.md",
    "category": "Study",
    "title": "Turbopack",
    "content": "\n<img src='https://github.com/user-attachments/assets/bf424249-6c33-4964-a258-0c9b502fbcf3' alt='turbopack' />\n\n# Turbopack: RSC와 TS를 위한 고성능 번들러\n\n웹 개발에서 **번들러**(Bundler)는 현대적인 웹 애플리케이션을 만드는 데 필수적인 도구입니다. 오늘은 **Turbopack**이라는 Next.js에 최적화된 최신 번들러를 소개하려 합니다. 왜 Turbopack이 필요한지, 그리고 기존 번들러와 무엇이 다른지 알아보겠습니다.\n\n> Next.js와 Turbopack 공식 문서를 번역한 내용입니다.\n\n> Turbopack은 현재 Next.js 개발 서버에서만 사용할 수 있습니다.  \n> 프로덕션 빌드는 아직 지원하지 않습니다.\n\n---\n\n## Turbopack이 등장한 배경\n\nNext.js 팀은 성능 개선을 위해 수많은 JS 기반 도구를 교체해왔습니다. Babel과 Terser를 대체했고, 이제 목표는 Webpack을 대체하는 것이었습니다. 그러나 시장에 나와 있는 다른 번들러들을 검토한 끝에, 우리는 새로운 번들러를 직접 개발하기로 결정했습니다. **왜냐하면 Turbopack은 기존 번들러들이 해결하지 못했던 문제들을 혁신적으로 해결하기 때문입니다.**\n\n---\n\n## Turbopack의 주요 특징\n\n### 1. 통합 그래프 (Unified Graph)\n\nNext.js와 같은 프레임워크가 인기를 끌게 된 큰 이유 중 하나는, 현재 세대의 번들러로 SSR(서버 사이드 렌더링)이나 RSC(React Server Components)와 같은 기능을 구현하는 것이 간단하지 않기(non-trivial하기) 때문입니다. 각 출력 환경(브라우저, 서버 등)에 맞는 여러 컴파일러를 만들어야 하고, 이 컴파일러들이 생성한 번들이 올바르게 결합되도록 서로 간의 통신을 관리해야 합니다.\n\n우리는 이러한 유지 관리의 부담을 Next.js와 Turbopack을 사용하는 모든 프레임워크에서 제거하고자 했습니다. 또한, 여러 환경을 위한 번들을 생성할 수 있는 단일 통합 그래프를 설계함으로써 더 깔끔하고 안정적인 구현을 만들 수 있었습니다.\n\n### 2. 번들링 vs 네이티브 ESM\n\nVite와 같은 프레임워크는 개발 모드에서 애플리케이션 소스 코드를 번들링하지 않는 방식을 사용합니다. 대신 브라우저의 네이티브 ES 모듈(ES Modules) 시스템에 의존합니다. 이 방식은 단일 파일만 변환하면 되기 때문에 매우 빠른 업데이트를 제공할 수 있습니다.\n\n우리도 이 방식을 실험해 보았지만, 많은 모듈로 구성된 대규모 애플리케이션에서는 확장성 문제를 겪었습니다. 브라우저에서 발생하는 수많은 네트워크 요청이 초기 실행 시간을 상대적으로 느리게 만들었기 때문입니다. 브라우저 입장에서는, 코드가 가능한 적은 네트워크 요청으로 전달될 때 실행 속도가 더 빨라집니다. 이는 로컬 서버에서도 마찬가지입니다.\n\n이런 이유로, 우리는 webpack처럼 Turbopack이 개발 서버에서 코드를 번들링하도록 결정했습니다. 특히 Turbopack은 Rust로 작성되어 있으며, 프로덕션에서만 필요한 최적화 작업을 건너뛰기 때문에 대규모 애플리케이션에서도 훨씬 빠르게 동작할 수 있습니다.\n\n### 3. 증분 계산 (Incremental Computation)\n\nTurbopack은 두 가지 방식을 사용해 속도를 극대화합니다:\n- **작업 최소화**: 불필요한 작업을 줄입니다.\n- **병렬 처리**: 여러 코어에서 작업을 동시에 처리합니다.\n\nTurbo 엔진은 작업 결과를 캐싱하여 동일한 작업을 반복하지 않도록 설계되었습니다. 이를 통해 최소한의 작업으로 최대 속도를 달성합니다.\n\n### 4. 지연 번들링 (Lazy Bundling)\n\n기존의 Next.js는 개발 모드에서 전체 웹 앱을 번들링했지만, 이는 비효율적이라는 결론에 도달했습니다. 최신 Next.js는 요청된 페이지와 해당 모듈만 번들링하는 방식으로 전환되었습니다. Turbopack은 이 접근법을 더욱 효율적으로 구현하며, 요청된 모듈만 번들링하여 빠른 개발 서버를 제공합니다.\n\n---\n\n## 시작하기\n\nTurbopack은 JavaScript와 TypeScript에 최적화된 **증분 번들러**로, Rust로 작성되었습니다. Webpack과 Next.js를 개발한 Vercel 팀이 10년간의 경험과 최신 기술을 바탕으로 설계한 Turbopack은 미래의 컴퓨팅을 지원할 준비가 되어 있습니다.\n\n**Turbopack의 성능 비결**은 두 가지입니다:\n- **고도로 최적화된 머신 코드**\n- **낮은 수준의 증분 계산 엔진**\n\n한 번 작업한 결과는 캐싱되어 동일한 작업을 다시 수행하지 않습니다. 또한 Turbopack은 Turborepo와 Google의 Bazel에서 영감을 받은 혁신적인 증분 계산 방식을 사용합니다.\n\nTurbopack은 현재 Next.js 개발 서버에서 사용할 수 있습니다. 아래 명령어를 사용해 Turbopack을 체험해보세요:\n\n```\nnpm run dev -- --turbopack\n```\n\n**주의:** `next build` 명령어를 사용한 프로덕션 빌드는 아직 지원되지 않습니다.\n\n이슈가 있다면 Next.js 리포지토리의 이슈 템플릿을 사용해 피드백을 보내주세요. 여러분의 의견은 Turbopack의 발전에 큰 도움이 됩니다.\n\n---\n\n## 요약: Turbopack을 선택한 이유\n\nTurbopack은 다음과 같은 이유로 탄생했습니다:\n\n1. **통합 그래프 지원**: 단일 컴파일러로 여러 환경을 타겟팅할 수 있습니다.\n2. **번들러 성능 최적화**: 큰 애플리케이션에서도 Native ESM보다 효율적입니다.\n3. **증분 계산 도입**: 작업량을 줄이고 속도를 극대화합니다.\n4. **lazy asset graph**: 필요한 asset만 번들링하여 빠른 시작 속도를 제공합니다.\n\n---\n\n## 참고\n\n- https://nextjs.org/docs/app/api-reference/turbopack\n- https://turbo.build/pack/docs",
    "tags": [
      "browser",
      "bundler"
    ],
    "date_started": "2024.12.14",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/study/turbopack.md",
    "preview": ""
  },
  {
    "id": "posts/study/javascript_usage.md",
    "category": "Study",
    "title": "Javascript Usage",
    "content": "\n<img width=\"720\" alt=\"image\" src=\"https://github.com/user-attachments/assets/20885936-1b8c-48f4-b5f5-11bc362849b6\">\n\n> Javascript의 기본 사용법을 모아 정리했다.\n\n# javascript 정리\n\n\n> [w3schools - JS Tutorial](https://www.w3schools.com/js)\n\n### var vs let\n\n- scope: var는 함수 스코프, let은 블록 스코프\n- hoisting: var는 선언 전에 사용 가능하다. let은 선언 전에 사용하면 ReferenceError가 발생한다.\n- redeclaration: var는 재선언이 가능하다. let은 재선언이 불가능하다.\n- global object: var는 window object의 property로 등록된다(binding). let은 window object의 property로 등록되지 않는다.\n\n### Number\n\n- bit: 64bit\n- `Number.MAX_SAFE_INTEGER`: 2^53-1\n- `Number.MIN_SAFE_INTEGER`: -(2^53-1)\n- `Number.MAX_VALUE`: 1.7976931348623157e+308\n- `Number.MIN_VALUE`: 5e-324\n- `Number.EPSILON`: 2^-52\n\n```javascript\nconsole.log(Number.MAX_SAFE_INTEGER);\n// 9007199254740991\n\nconsole.log(Number.MIN_SAFE_INTEGER);\n// -9007199254740991\n\nconsole.log(Number.MAX_VALUE);\n// 1.7976931348623157e+308\n\nconsole.log(Number.MIN_VALUE);\n// 5e-324\n\nconsole.log(Number.EPSILON);\n// 2.220446049250313e-16\n```\n\n\n### BigInt\n\n- 2^53-1보다 큰 정수를 표현할 수 있다.\n- `n`을 붙여서 표현한다.\n\n```javascript\nconst bigInt1 = 1234567890123456789012345678901234567890n;\nconst bigInt2 = BigInt(\"1234567890123456789012345678901234567890\");\n\n```\n\n### ?? operator\n\n- nullish coalescing operator\n- `null` 또는 `undefined`일 때만 우측의 값을 반환한다.\n\n```javascript\nconst foo = null ?? \"default string\";\nconsole.log(foo);\n// \"default string\"\n\nconst bar = 0 ?? 42;\nconsole.log(bar);\n// 0\n```\n\n### ~ operator\n\n- bitwise NOT operator\n- `~n`은 `-n-1`을 반환한다.\n- 소수점 제거에 활용 가능 (64bit -> 32bit)\n\n```javascript\nconsole.log(~2);\n// -3\n\nconsole.log(~~5.512);\n// 5\n```\n\n## 손님? 아니, Object가 왕이다.\n\"If you Understand Objects, you Understand JavaScript.\"\n\n오브젝트는 프로퍼티와 메소드를 담는 컨테이너이다.\n\n프로퍼티는 이름이 있는 값이다.\n\n메소드는 프로퍼티로서 저장된 함수이다.\n\n프로퍼티는 원시값, 함수, 또는 다른 오브젝트가 될 수 있다.\n\n오브젝트 목록\n- Objects\n- Maths\n- Functions\n- Dates\n- Arrays\n- Maps\n- Sets\n\n원시값을 제외한 모든 자바스크립트 값이 오브젝트에 해당한다.\n\n#### 생성자: 모든 자바스크립트 오브젝트는 생성자 property가 있다. 이는 생성자 함수라고 불린다.\n\n```javascript\nconst x = {};\nconsole.log(x.constructor);\n// [Function: Object]\n\nfunction Person(first, last, age, eyecolor) {\n  this.firstName = first;\n  this.lastName = last;\n  this.age = age;\n  this.eyeColor = eyecolor;\n  this.nationality = \"English\";\n}\n\nconst myFather = new Person(\"John\", \"Doe\", 50, \"blue\");\nconsole.log(myFather);\n// Person{...}\n\n```\n\nProperty 추가하기  \n\n```javascript\n\nfunction Person(first, last, age, eyecolor) {\n  this.firstName = first;\n  this.lastName = last;\n  this.age = age;\n  this.eyeColor = eyecolor;\n  this.nationality = \"English\";\n}\n\nconst myFather = new Person(\"John\", \"Doe\", 50, \"blue\");\nconsole.log(myFather);\n\nPerson.area = 'London'\nconsole.log(myFather.area)\n// undefined\n\nPerson.prototype.area = 'London'\nconsole.log(myFather.area)\n// London\n\n```\n\ninstance를 만든 후에 Property를 추가해도 default value를 가지는 것이 신기했다.\n\n원리:  \n- `myFather`는 `Person`의 instance이다.\n- `Person`의 prototype에 `area` property를 추가하면, `myFather`의 prototype chain에도 `area` property가 추가된다.\n- `myFather`의 prototype chain에 `area` property가 없기 때문에 `Person`의 prototype chain을 타고 올라가 `area` property를 찾는다.\n\nBuilt-in JavaScript 생성자들  \nJavaScript has built-in 생성자들 for all native objects:  \n\n```javascript\nnew Object()   // A new Object object\nnew Array()    // A new Array object\nnew Map()      // A new Map object\nnew Set()      // A new Set object\nnew Date()     // A new Date object\nnew RegExp()   // A new RegExp object\nnew Function() // A new Function object\n```\n\n> Note:\n`Math`가 없는데 이는 global object이다. `new` 키워드는 `Math`에 사용될 수 없다.\n\n### 알고 있지? 간단한 생성자\n\n`new Object()` 대신 `{}`를 사용하자.\n\n`new Array()` 대신 `[]`를 사용하자.\n\n`new RegExp()` 대신 `/()/`를 사용하자.\n\n`new Function()` 대신 `() {}`를 사용하자.\n\n```javascript\n\"\";           // primitive string\n0;            // primitive number\nfalse;        // primitive boolean\n\n{};           // object object\n[];           // array object\n/()/          // regexp object\nfunction(){}; // function\n```\n\n### Prototypes\n\n모든 JavaScript 오브젝트는 prototype의 property와 methods를 상속한다.\n\n### Primitives\n\nprimitives는 property와 method가 없는 값이다.\n\n3.14는 primitive value이다.\n\nPrimitive 데이터 타입은 primitive value를 값으로 하는 데이터이다.\n\n#### 7개의 자바스크립트 primitive 데이터 타입:\n\n- string\n- number\n- boolean\n- null\n- undefined\n- symbol\n- bigint\n\n#### 특징\n- immutable: 수정 불가.\n- Object는 mutable: 수정 가능.\n\n### generator function\n\nGenerator Function이란?\n\nGenerator Function은 일반적인 함수와 달리 실행을 중간에 멈췄다가(중단), 나중에 다시 실행할 수 있는 함수예요.\n\n이 함수를 선언하려면 function*이라는 키워드를 사용해요.\n호출하면 함수가 바로 실행되지 않고, 대신 Generator 객체를 반환해요.\n\nBinding의 역할\n\nfunction* 선언문을 사용하면, Generator Function을 특정 이름에 바인딩(binding)해요.\n\n예를 들어, function* myGenerator() {}는 myGenerator라는 이름으로 이 Generator Function을 참조하도록 binding을 만든 거예요.\nGenerator의 특징\n\nGenerator Function은 멈출 수 있는 함수예요.\n실행이 중단된 상태에서도 내부의 변수와 상태(context)가 그대로 유지돼요.\n다시 실행하면 멈췄던 지점부터 이어서 동작해요.\n이 기능은 yield 키워드를 통해 구현돼요.\nGenerator Function의 두 가지 작성법\n\nDeclaration 방식: function* 키워드를 사용해 이름이 있는 Generator를 선언.\n\nExpression 방식: 익명 함수로 정의하거나 다른 이름에 할당.\n\n예제\n\n```javascript\n\n// Declaration 방식\nfunction* generatorExample() {\n  yield 1; // 1 반환하고 멈춤\n  yield 2; // 2 반환하고 멈춤\n  return 3; // 3 반환하고 끝냄\n}\n\n// 사용\nconst gen = generatorExample();\nconsole.log(gen.next()); // { value: 1, done: false }\nconsole.log(gen.next()); // { value: 2, done: false }\nconsole.log(gen.next()); // { value: 3, done: true }\n\n// Expression 방식\nconst anotherGenerator = function* () {\n  yield 'Hello';\n  yield 'World';\n};\nconst gen2 = anotherGenerator();\nconsole.log(gen2.next()); // { value: 'Hello', done: false }\nconsole.log(gen2.next()); // { value: 'World', done: false }\n```\n\n단어 설명\n\nGenerator Function: 중간에 실행을 멈추고, 다시 시작할 수 있는 특수한 함수.\n\nYield: Generator에서 값을 반환하고 실행을 멈추는 키워드.\n\nBinding: 특정 이름(identifier)과 Generator Function을 연결하는 작업.\n\nContext: 실행 중인 함수가 사용하는 변수와 상태.\n\nGenerator는 복잡한 작업(예: 비동기 처리, 반복 가능한 데이터 생성)을 단순하게 표현하는 데 유용합니다.\n\n### binding\n\n프로그래밍에서 binding은 특정 이름(identifier)과 어떤 값(value)을 연결하는 것을 의미해요. 이때 모든 binding이 \"변수\"는 아니에요. 예를 들어, 함수의 매개변수(parameter)나 catch (e) 블록에서 만들어지는 binding은 엄격한 의미에서 \"변수\"라고 부르지 않아요.\n\n또한, 일부 binding은 프로그래밍 언어에 의해 자동으로 생성되기도 해요. 예를 들어, JavaScript에서는 this나 new.target 같은 것이 이에 해당해요.\n\nBinding의 두 가지 주요 특징:\n\nMutable (변경 가능): binding에 새로운 값을 다시 할당할 수 있다면 mutable이라고 해요.\n\nImmutable (변경 불가능): binding에 새로운 값을 할당할 수 없다면 immutable이라고 해요.\n\n⚠️ 하지만, binding이 immutable이라고 해서 그것이 가리키는 값(value) 자체도 변경 불가능한 것은 아니에요. (예: 객체의 속성은 바뀔 수 있음)\n\nScope와의 관계:\nBinding은 일반적으로 특정 스코프와 연관되어 있어요.\n\n어떤 프로그래밍 언어에서는 같은 스코프에서 binding을 다시 만들 수 있어요(redeclare).\n그러나 다른 언어에서는 이게 불가능해요.\nJavaScript에서는 binding을 만드는 방법에 따라 재선언이 가능한지 여부가 달라져요. (예: var, let, const의 차이점)\n\n단어 설명\n\nIdentifier: 식별자. 프로그래밍에서 값을 식별하기 위한 이름.\nScope: 스코프. 특정 코드에서 변수를 접근할 수 있는 범위.\nReassign/Mutable: 다시 할당하다, 변경 가능하다.\nImmutable: 변경 불가능한.\n추가로 이해를 돕는 예제를 첨부할게요.\n\n```javascript\n// mutable binding\nlet x = 10;\nx = 20; // 값을 다시 할당 가능\n\n// immutable binding\nconst y = 30;\n// y = 40; // Error: y는 값을 다시 할당할 수 없음\n\n// 함수 매개변수도 binding의 한 종류\nfunction greet(name) {\n  console.log(name); // name은 binding이지만 변수로 보지 않을 수 있음\n}\n\n// language-defined binding\nfunction example() {\n  console.log(this); // this는 언어에 의해 자동 생성됨\n}\n```\n\nGenerator Function과 binding의 관계를 명확히 설명하겠습니다.\n\n1. Generator Function 선언과 Binding\n\nfunction* 선언문은 특정 이름(identifier)에 Generator Function을 binding합니다.\n\n이 binding은 Generator Function의 정의와 특정 이름을 연결해 주는 역할을 해요.\n예를 들어, 아래 코드는 myGenerator라는 이름에 Generator Function을 바인딩한 것입니다.\n\n```javascript\nfunction* myGenerator() {\n  yield 1;\n  yield 2;\n}\n```\n\n위 코드에서 myGenerator는 이름(binding)이고, 이 이름으로 Generator Function에 접근할 수 있어요.\n\n2. Binding의 Scope와 Context\n\nGenerator Function 내부에서도 binding의 개념이 중요한데요:\n\nGenerator는 **실행을 멈춘 상태에서 변수와 컨텍스트(binding 상태)**를 유지합니다.\n다시 실행될 때, 중단된 시점의 변수 값(binding 상태)을 그대로 사용합니다.\n예를 들어:\n\n```javascript\nfunction* counter() {\n  let count = 0; // count는 Generator의 내부 binding\n  while (true) {\n    yield count++;\n  }\n}\n\nconst gen = counter();\nconsole.log(gen.next().value); // 0 (count는 0)\nconsole.log(gen.next().value); // 1 (count가 1로 업데이트된 상태 유지)\n```\n\n이 예제에서 count라는 binding은 Generator가 멈추고 재실행되는 동안에도 저장돼 있습니다.\n\n3. Binding 방식에 따른 차이\n\nGenerator Function은 선언(declaration) 또는 표현식(expression)을 통해 binding할 수 있어요.\n\nDeclaration 방식\n\nGenerator Function을 이름에 바인딩합니다.\n\n바인딩된 이름은 해당 Generator를 호출하거나 사용할 때 쓰입니다.\n\n```javascript\nfunction* myGenerator() {\n  yield 'A';\n}\nconst gen = myGenerator(); // myGenerator라는 binding 사용\n```\n\nExpression 방식\n\nGenerator Function을 익명 함수로 생성하고, 다른 변수에 바인딩할 수 있습니다.\n\n```javascript\nconst myGenerator = function* () {\n  yield 'B';\n};\nconst gen = myGenerator(); // myGenerator라는 binding 사용\n```\n\n4. 언어 정의 Binding (Language-defined Bindings)와 Generator\nGenerator 내부에서도 언어가 자동으로 만들어주는 binding이 있습니다. 예를 들어:\n\nthis: Generator Function 내부에서 사용할 수 있는 특별한 binding입니다.\n\n컨텍스트를 활용해 상태를 유지합니다.\n\n단어 설명\n\nDeclaration: 선언. 이름과 기능을 명시적으로 연결하는 방식.\n\nExpression: 표현식. 익명 함수 등을 변수에 바인딩해 사용하는 방식.\n\nContext: 실행 중인 함수의 상태와 변수들이 저장된 환경.\n\nScope: 스코프. binding이 접근 가능한 범위.\n\n요약\n\nGenerator Function은 특정 이름에 바인딩될 뿐만 아니라, 내부 상태(변수)도 context로 유지하며 binding을 활용합니다. \n\n---\n\n<img src=\"https://github.com/user-attachments/assets/de863d94-0958-4417-9e4f-49180d36109d\" width=\"640\" />\n\n\n### Template Strings  \nTemplate Strings은 ES6 (JavaScript 2016)에 나왔다.\n\nTemplates은 백틱으로 감싸인 문자열이다. (\\`This is a template string\\`)\n\ntemplate string 안에 single quote(')와 double quote(\")를 사용할 수 있다.\n\n```javascript\nlet text = `He's often called \"Johnny\"`;\n```\n\n### slice(i, j)\ni에서 j-1까지의 문자열을 반환한다.\n\n```javascript\nlet str = \"Apple, Banana, Kiwi\";\nconsole.log(str.slice(7, 13));\n// Banana\nconsole.log(str.slice(-12, 13));\n// Banana\nconsole.log(str.slice(-12, -6));\n// Banana\n```\n\n### substring(i, j)\n\nslice와 비슷하지만 음수를 받을 수 없다.\n받으면 0으로 처리한다.\n\n```javascript\nlet str = \"Apple, Banana, Kiwi\";\nconsole.log(1, str.substring(7, 13));\n// 1 Banana\nconsole.log(2, str.substring(-12, 13));\n// 2 Apple, Banana\nconsole.log(3, str.substring(-12, -6));\n// 3 \n```\n\n### substr(i, length) ( deprecated )\n\ni부터 length만큼의 문자열을 반환한다.\n\n```javascript\nlet str = \"Apple, Banana, Kiwi\";\nconsole.log(str.substr(7, 6));\n// Banana\nconsole.log(str.substr(-12, 6));\n// Banana\nconsole.log(str.substr(-12, -6));\n// \n```\n\n### 참고자료\n\n- [MDN web docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript)\n- [w3schools](https://www.w3schools.com/js/default.asp)",
    "tags": [
      "ECMA",
      "javascript",
      "string"
    ],
    "date_started": "2024.12.10",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/study/javascript_usage.md",
    "preview": ""
  },
  {
    "id": "posts/study/recoil.md",
    "category": "Study",
    "title": "Recoil",
    "content": "\n<img src='https://github.com/user-attachments/assets/8f8c6115-e777-42cf-9187-11974be227b6' alt='recoil' width='200px' />\n\n# Recoil이란?\n\n**Recoil**은 React를 위한 상태 관리 라이브러리로, 컴포넌트 간의 상태를 공유하거나 상태 기반의 파생 데이터를 효율적으로 관리할 수 있도록 설계되었습니다. Recoil은 상태를 **Atom**(상태 단위)과 **Selector**(순수 함수)로 구성하며, 이를 통해 데이터 흐름 그래프를 생성합니다.\n\n---\n\n## Core Concepts\n\n### 1. Atoms\n**Atoms**는 상태의 기본 단위로, **업데이트 가능**하며 **구독 가능**합니다.\n- 컴포넌트가 Atom에 구독되면, Atom이 변경될 때 해당 컴포넌트가 재렌더링됩니다.\n- Atom은 React의 `useState`처럼 동작하지만, 여러 컴포넌트에서 공유할 수 있다는 점이 다릅니다.\n- Atom은 **유일한 키(key)**와 **기본값(default)**으로 정의됩니다.\n\n#### 주요 특징\n- 컴포넌트 간 상태 공유 가능.\n- 런타임 중 생성 가능.\n- 전역적으로 고유한 키 필요.\n\n#### Atom 정의\nAtom은 `atom()` 함수를 사용해 생성됩니다. 아래는 간단한 예시입니다:\n\n```javascript\nconst fontSizeState = atom({\n  key: 'fontSizeState',\n  default: 14,\n});\n```\n\n1. Atom은 고유한 키를 가져야 합니다.\n2. 기본값은 초기 상태를 정의합니다.\n\n#### Atom 읽기 및 쓰기\n`useRecoilState()` 훅을 사용하여 Atom의 값을 읽거나 업데이트할 수 있습니다. \n\n```javascript\nfunction FontButton() {\n  const [fontSize, setFontSize] = useRecoilState(fontSizeState);\n  return (\n    <button onClick={() => setFontSize((size) => size + 1)} style={{ fontSize }}>\n      Click to Enlarge\n    </button>\n  );\n}\n```\n\n---\n\n### 2. Selectors\n**Selectors**는 순수 함수로, Atom이나 다른 Selector를 입력받아 파생 데이터를 계산합니다.\n- **파생 데이터(derived data)**: 저장된 최소 상태에서 계산된 데이터.\n- Selectors는 Atom과 동일한 방식으로 컴포넌트에서 구독 가능하며, 데이터 변경 시 재계산됩니다.\n\n#### 주요 특징\n- 중복된 상태를 방지하고, 효율적인 데이터 관리를 지원.\n- Atom 및 다른 Selector 의존성을 추적하여 필요한 경우에만 재계산.\n\n#### Selector 정의\nSelector는 `selector()` 함수로 정의됩니다. 아래는 Atom의 값을 기반으로 포맷된 문자열을 반환하는 예시입니다:\n\n```js\nconst fontSizeLabelState = selector({\n  key: 'fontSizeLabelState',\n  get: ({ get }) => {\n    const fontSize = get(fontSizeState);\n    const unit = 'px';\n    return `${fontSize}${unit}`;\n  },\n});\n```\n\n1. Selector는 고유한 키를 가져야 합니다.\n2. `get` 속성으로 계산 로직을 정의합니다.\n3. `get` 함수는 다른 Atom이나 Selector 값을 참조합니다.\n\n#### Selector 값 읽기\nSelector 값은 `useRecoilValue()` 훅을 사용해 읽을 수 있습니다.\n\n```js\nfunction FontButton() {\n  const [fontSize, setFontSize] = useRecoilState(fontSizeState);\n  const fontSizeLabel = useRecoilValue(fontSizeLabelState);\n\n  return (\n    <>\n      <div>Current font size: {fontSizeLabel}</div>\n      <button onClick={() => setFontSize((size) => size + 1)} style={{ fontSize }}>\n        Click to Enlarge\n      </button>\n    </>\n  );\n}\n```\n\n---\n\n## Recoil의 장점\n1. **유연성**: React의 로컬 상태 관리처럼 간단하면서도 전역 상태를 쉽게 관리할 수 있습니다.\n2. **확장성**: 대규모 애플리케이션에서도 효율적인 상태 관리 가능.\n3. **효율성**: 의존성 기반으로 필요한 경우에만 재계산.\n\n---\n\n### 📝 용어 설명\n- **Atom**: Recoil의 기본 상태 단위. React의 `useState`와 비슷하지만, 공유 가능한 상태.\n- **Selector**: Atom이나 다른 Selector를 기반으로 계산된 파생 데이터를 제공하는 순수 함수.\n- **Derived Data**: 최소 상태에서 계산된 데이터.\n\nRecoil은 간단한 API와 React 친화적인 방식으로, 상태 관리의 복잡성을 크게 줄여줍니다. ✨\n\n\n# motivation\n\n> 개인 블로그 프로젝트 상태 관리 방식으로 redux, recoil 그리고 react의 useContext를 고려했습니다.  \n\n## Redux, Recoil, useContext 비교\n\n| 특징                          | Redux                                                                | Recoil                                                  | useContext                                                               |\n|-------------------------------|----------------------------------------------------------------------|---------------------------------------------------------|---------------------------------------------------------------------------|\n| **목적**                       | 복잡한 애플리케이션을 위한 상태 관리                              | React에 최적화된 상태 관리                               | 컴포넌트 간 상태를 prop drilling 없이 공유                               |\n| **학습 곡선**                  | 가파름, 액션, 리듀서, 미들웨어를 이해해야 함                       | 중간, React 개발자는 쉽게 배울 수 있음              | 쉬움, 설정이 최소화되어 있음                                             |\n| **상태 세분화**                | 중앙집중식 상태, 상태 변경 시 전체 상태 트리 업데이트             | 세분화된 atom 기반 상태 업데이트                        | 상태 변경 시 모든 소비자에게 영향을 미침                                 |\n| **성능**                       | 최적화하지 않으면 불필요한 리렌더링이 발생할 수 있음               | React 최적화, 불필요한 리렌더링 방지                    | 상태 변경 시 모든 소비자 리렌더링이 발생할 수 있음                       |\n| **미들웨어 지원**             | 강력함, 많은 커뮤니티에서 만든 미들웨어 사용 가능                 | 직접적인 미들웨어 지원 없음, React 효과 사용           | 해당 없음                                                                |\n| **비동기 처리**                | redux-thunk 또는 redux-saga와 같은 미들웨어 필요                  | 비동기 셀렉터에 대한 내장 지원                           | 비동기 처리는 수동으로 처리해야 함                                        |\n| **확장성**                     | 대형, 복잡한 애플리케이션에 적합                                   | 중형에서 대형 애플리케이션에 적합                        | 작은 또는 중형 애플리케이션에 적합                                       |\n| **설정 복잡도**                | 스토어, 리듀서, 액션, 미들웨어 설정이 필요                       | 최소 설정, React 훅 사용                                 | 설정이 매우 간단                                                       |\n| **TypeScript 지원**           | 강력함, 액션과 리듀서의 타입 정의 필요                             | 좋은 지원, atom/selector에 대한 타입 지원               | 직관적, useContext는 React의 타입 정의와 바로 통합                        |\n| **사용 사례**                  | 복잡한 상태 흐름을 가진 중앙집중식 상태 관리에 적합               | 분산형 상태 관리, React 최적화된 워크플로우             | 간단한 전역 상태 공유, 추가 라이브러리 필요 없음                         |\n\n\n> 프로젝트의 사이즈가 작고 state의 insert가 한 번 일어난다는 점에서 보다 단순한 방법 recoil을 채택했습니다.\n\n---\n\n### 참고 자료\n- https://recoiljs.org/",
    "tags": [
      "react",
      "state-management"
    ],
    "date_started": "2024.12.08",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/study/recoil.md",
    "preview": ""
  },
  {
    "id": "posts/study/babel_esbuild.md",
    "category": "Study",
    "title": "Babel_Esbuild",
    "content": "\n<img src= 'https://github.com/user-attachments/assets/bfb7cb3b-97a4-473f-9e73-43d522cb27c6'\nalt='babel'>\n\n> Babel, esbuild 공식 문서를 정리한 내용입니다.\n\n# Babel이란?\n\n**Babel**은 JavaScript 컴파일러로, 최신 ECMAScript(ES2015+) 코드를 현재 및 이전 브라우저나 환경에서도 실행할 수 있도록 변환해주는 **도구 체인(toolchain)**입니다. 주요 기능과 활용 방법은 아래와 같습니다.\n\n---\n\n## 주요 기능\n\n### 1. 문법 변환 (Transform Syntax)\n\nBabel은 최신 JavaScript 문법을 이전 버전의 JavaScript로 변환합니다. 예를 들어, ES2015의 화살표 함수는 ES5의 일반 함수로 변환됩니다.\n\n```javascript\n// Babel 입력: ES2015 화살표 함수\n[1, 2, 3].map((n) => n + 1)\n\n// Babel 출력: ES5 등가 코드\n[1, 2, 3].map( \n  function (n) {\n    return n + 1\n  }\n)\n```\n\n### 2. 폴리필 (Polyfill)\n\nBabel은 타겟 환경에서 지원되지 않는 기능을 동작하도록 하는 폴리필(polyfill)을 지원합니다. 예를 들어, `core-js`와 같은 서드파티 라이브러리를 통해 최신 JavaScript 기능을 사용할 수 있습니다.\n\n### 3. JSX 및 React 지원\n\nBabel은 JSX 문법을 변환할 수 있습니다. React 개발에 필요한 `@babel/preset-react`를 사용하면 JSX 변환을 간단히 설정할 수 있습니다.\n\n설치 방법\n\n```bash\nnpm install --save-dev @babel/preset-react\n```\n\njsx 예시\n\n```jsx\nexport default function DiceRoll() {\n  const [num, setNum] = React.useState(Math.ceil(Math.random() \\* 6));\n\n  const handleClick = () => {\n    setNum(Math.ceil(Math.random() \\* 6));\n  };\n\n  return (\n    <div>\n      Your dice roll: {num}.\n      <button onClick={handleClick}>\n        Click to get a new number\n      </button>\n    </div>\n  );\n}\n```\n\n4.  타입 주석 제거 (Type Annotations)\n    Babel은 Flow와 TypeScript의 타입 주석을 제거할 수 있습니다. 다만, 타입 검사 자체는 수행하지 않으므로, 타입 검사를 위해서는 Flow 또는 TypeScript를 별도로 사용해야 합니다.\n\nTypeScript 프리셋 설치\n\n```bash\nnpm install --save-dev @babel/preset-typescript\n```\n\nts 예시\n\n```typescript\nfunction Greeter(greeting: string) {\n  this.greeting = greeting\n}\n```\n\n5.  플러그인 기반 설계 (Pluggable)\n    Babel은 플러그인 기반으로 동작합니다. 다양한 변환을 위한 플러그인을 조합하거나, 직접 플러그인을 작성하여 사용할 수 있습니다.\n\n예시: 간단한 Babel 플러그인\n\n```javascript\n// A plugin is just a function\nexport default function ({ types: t }) {\n  return {\n    visitor: {\n      Identifier(path) {\n        const name = path.node.name\n        path.node.name = name.split('').reverse().join('')\n      },\n    },\n  }\n}\n```\n\n6. 디버깅 지원\n   Babel은 **소스 맵(source map)**을 지원하여 컴파일된 코드도 디버깅하기 쉽게 만듭니다.\n\n### Babel의 장점\n\n1. **표준 준수**: ECMAScript 표준을 가능한 한 충실히 따릅니다.\n2. **경량화**: 불필요한 런타임 종속성을 최소화하여 파일 크기를 줄이고 성능을 높입니다.\n\n### 📝 용어 설명\n\n- **ECMAScript (ES)**: JavaScript의 표준 사양.\n- **Compiler (컴파일러)**: 코드를 다른 형태로 변환해주는 프로그램.\n- **Syntax (문법)**: 프로그래밍 언어의 구조와 규칙.\n- **Polyfill (폴리필)**: 특정 기능이 없는 환경에서도 해당 로직이 작동하도록 도와주는 코드.\n\nBabel은 최신 JavaScript 개발에서 중요한 도구로, 호환성과 확장성을 동시에 제공합니다. ✨\n\n---\n\n<img src= 'https://github.com/user-attachments/assets/d99c5959-815d-46d8-b38d-416d40a62ff8' alt='esbuild' />\n\n# ESBuild란?\n\nESBuild는 최신 웹 애플리케이션 개발에서 빌드 도구의 속도와 성능을 대폭 향상시키기 위해 설계된 초고속 번들러입니다. ESBuild는 **Go 언어**로 작성되었으며, 현대적인 웹 애플리케이션 개발을 지원하는 여러 기능을 제공합니다.\n\n---\n\n## 주요 기능\n\n- **초고속 빌드 속도** (캐시 없이도 빠름)\n- **JavaScript, CSS, TypeScript, JSX** 지원\n- 간단한 CLI, JavaScript, Go API\n- **ESM** 및 **CommonJS 모듈** 번들링\n- **CSS 번들링** 및 **CSS 모듈** 지원\n- **트리 쉐이킹(Tree Shaking)**, **코드 축소(Minification)**, **소스맵** 생성\n- **로컬 서버**, **파일 변경 감지(Watch Mode)**, **플러그인** 시스템 제공\n\n---\n\n## ESBuild가 빠른 이유\n\n1. **Go 언어로 개발**  \n   Go는 병렬 처리가 강력하며, JavaScript보다 성능 최적화가 잘 이루어져 있습니다. JavaScript 기반 번들러와 달리 ESBuild는 네이티브 코드로 컴파일되어 실행 속도가 매우 빠릅니다.\n\n   **병렬 처리**: Go는 여러 CPU 코어를 효율적으로 활용하여 처리 속도를 극대화합니다.  \n   **메모리 공유**: Go의 스레드는 메모리를 공유하므로 작업 간 데이터 직렬화(serialization)가 필요 없습니다.\n\n   > **병렬 처리**: 여러 작업을 동시에 수행하여 속도를 향상시키는 기법.  \n   > **직렬화**: 데이터를 저장하거나 전송하기 위해 형식에 맞춰 변환하는 과정.\n\n2. **전체 로직 자체 개발**  \n   ESBuild는 외부 라이브러리에 의존하지 않고 모든 로직을 직접 구현했습니다.\n\n   - 일관된 데이터 구조 사용\n   - 필요할 때 아키텍처 전체를 최적화 가능\n\n   예를 들어, 대부분의 번들러는 TypeScript 컴파일러를 사용하지만, ESBuild는 자체 TypeScript 파서를 사용하여 성능 병목을 최소화합니다.\n\n3. **최소한의 메모리 사용**  \n   ESBuild는 작업 데이터를 최소한의 메모리로 처리하여 CPU 캐시에 효율적으로 접근합니다.\n   - 데이터 변환 과정을 줄이고, 데이터 구조를 재사용하도록 설계\n   - 불필요한 메모리 할당을 방지\n\n---\n\n## 벤치마크 결과\n\n### JavaScript 번들링\n\n| 번들러          | 시간    | 상대 속도 | 처리 속도     | 번들 크기 |\n| --------------- | ------- | --------- | ------------- | --------- |\n| **ESBuild**     | 0.39초  | **1x**    | 1403.7 KLOC/s | 5.80 MB   |\n| Parcel 2        | 14.91초 | 38x       | 36.7 KLOC/s   | 5.78 MB   |\n| Rollup + Terser | 34.10초 | 87x       | 16.1 KLOC/s   | 5.82 MB   |\n| Webpack 5       | 41.21초 | 106x      | 13.3 KLOC/s   | 5.84 MB   |\n\n- ESBuild는 경쟁 도구보다 **10~100배** 빠릅니다.\n\n---\n\n## 주요 사용 사례\n\n1. **Vite와의 통합**: ESBuild는 Vite에서 TypeScript를 JavaScript로 변환하는 데 사용됩니다.\n2. **Snowpack**: 빠른 개발 환경 구축.\n3. **Amazon CDK** 및 **Phoenix**: 코드를 번들링하기 위해 활용.\n\n---\n\n## ESBuild의 한계\n\n- **타입 검사 미지원**: TypeScript의 타입 검사는 `tsc`를 별도로 실행해야 합니다.\n- **모든 언어 지원 X**: 예를 들어, Svelte, Vue, Elm은 지원하지 않습니다.\n- **핫 모듈 교체(HMR)**: 제공되지 않음.\n\n> ESBuild는 단순함과 성능을 위해 \"모든 기능을 갖춘 올인원 도구\"가 아니라, 번들링에 초점을 맞춘 도구입니다.\n\n---\n\nESBuild는 고성능 번들링 도구가 필요한 프로젝트에 적합하며, 최신 웹 개발에서 효율성과 생산성을 크게 향상시킬 수 있습니다.\n\n---\n\n### 참고\n\n- https://esbuild.github.io/\n- https://babeljs.io/docs/\n",
    "tags": [
      "browser",
      "transpiler"
    ],
    "date_started": "2024.12.06",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/study/babel_esbuild.md",
    "preview": ""
  },
  {
    "id": "posts/study/webpack_vite.md",
    "category": "Study",
    "title": "Webpack_Vite",
    "content": "\n<img src='https://github.com/user-attachments/assets/b6982d5e-cfd8-484d-a2ee-31019ff4088e' alt='webpack' width='200px' />\n\n> webpack, vite 공식 문서를 정리한 내용입니다.\n\n# Web Bundler: 웹 애플리케이션을 효율적으로 관리하기 위한 도구\n\n웹 개발에서는 여러 파일을 번들링(bundle)하여 최적화된 형태로 웹 브라우저에 전달하는 작업이 중요합니다. 이를 돕는 도구가 바로 **웹 번들러**입니다. 웹 번들러는 코드의 모듈을 결합하여 하나의 파일로 만들어주고, 그 과정에서 파일 크기를 줄이는 작업도 수행합니다. 또한, 각 모듈 간의 의존성을 처리하고, 다양한 브라우저 환경을 고려한 최적화 작업을 해줍니다.\n\n이 글에서는 대표적인 웹 번들러인 **Webpack**과 **Vite**를 비교하고, 최신 개발 트렌드에 적합한 트랜스파일러인 **Babel**과 **Esbuild**를 다룹니다.\n\n---\n\n## 요약\n\n**Webpack**은 **모듈 번들링**을 위한 도구로, 모든 의존성을 처리하고 여러 파일을 하나로 묶어주는 역할을 합니다. 복잡한 설정을 통해 자바스크립트, CSS, 이미지 파일 등을 효율적으로 번들링할 수 있습니다. 그러나 Webpack은 **구성이 복잡**하고, **빌드 속도**가 느려질 수 있습니다.\n\n반면, **Vite**는 Webpack의 단점을 보완하고자 만든 툴로, **빠른 개발 환경**을 제공하는 것이 특징입니다. Vite는 **ES 모듈(ESM)**을 기반으로 페이지를 빠르게 로드하고, 개발 중에는 **핫 모듈 리플레이스먼트(HMR)** 기능을 통해 페이지를 새로 고침하지 않고도 변경 사항을 즉시 반영할 수 있습니다. Vite는 **ESBuild**를 사용하여 트랜스파일링을 처리하는데, 이 덕분에 **빌드 속도**가 매우 빠릅니다.\n\n## Webpack: 전통적이지만 강력한 모듈 번들러\n\n<img src= 'https://github.com/user-attachments/assets/8c850ae2-cf4a-4975-b3b7-847f51043a8a' alt='webpack' />\n\n### 개요\n\n**Webpack**은 자바스크립트 애플리케이션을 위한 정적 모듈 번들러입니다. Webpack은 애플리케이션의 **엔트리 포인트(entry point)**를 기준으로 내부 **의존성 그래프(dependency graph)**를 생성한 후, 필요한 모듈을 번들로 묶습니다. 번들링된 결과는 배포를 위해 정적 자원으로 제공됩니다.\n\n### 주요 개념\n\n1. **Entry**: 번들링을 시작하는 진입점.\n2. **Output**: 번들 파일의 이름과 저장 위치를 지정.\n3. **Loaders**: CSS, 이미지, TypeScript 등 비(非)자바스크립트 파일을 변환.\n4. **Plugins**: 번들 최적화, 환경 변수 설정 등 다양한 작업 지원.\n5. **Mode**: 개발(development) 또는 프로덕션(production) 모드에 따른 최적화.\n\n### 장점\n\n- **유연한 설정**: 다양한 요구 사항에 맞게 구성 가능.\n- **광범위한 생태계**: 수많은 로더와 플러그인 지원.\n\n### 단점\n\n- 설정의 복잡성: 많은 설정이 필요할 수 있음.\n- 느린 빌드 속도: 대규모 애플리케이션에서는 초기 빌드와 HMR(Hot Module Replacement) 속도가 느려질 수 있음.\n\n### Babel\n\nWebpack은 보통 **Babel**과 함께 사용되어 최신 자바스크립트 문법을 구버전 브라우저에서도 실행 가능하도록 변환합니다. 예를 들어, 다음과 같은 설정을 통해 Babel을 로더로 추가할 수 있습니다:\n\n```javascript\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader',\n        },\n      },\n    ],\n  },\n}\n```\n\n## Vite: 차세대 번들러\n\n<img src= 'https://github.com/user-attachments/assets/d1d61b5e-cc58-4619-8c2a-c058c7e604e2'\nalt='vite' />\n\n### 개요\n\nVite는 Webpack의 한계를 극복하고자 만들어진 번들러로, 빠른 개발 환경을 제공하는 것이 특징입니다. Vite는 브라우저의 **ES 모듈(ESM)**을 적극 활용하며, Esbuild를 사용해 빌드 속도를 크게 향상시킵니다.\n\n### 주요 차이점\n\n1. **빠른 서버 시작**: Vite는 애플리케이션을 **의존성(dependencies)**과 **소스 코드(source code)**로 나누어, 의존성은 미리 번들링하고 소스 코드는 요청에 따라 처리합니다.\n\n2. **효율적인 HMR**: 변경된 파일만 정확히 갱신하므로 애플리케이션 크기에 상관없이 빠르게 업데이트.\n3. **HTTP 헤더 활용**: 브라우저 캐싱을 통해 재요청을 최소화.\n\n### Esbuild\n\nVite는 **Esbuild를** 사용해 의존성을 미리 번들링합니다. Esbuild는 Go 언어로 작성되어 기존 JavaScript 기반 도구보다 **10~100배** 빠른 속도를 자랑합니다.\n\n### 장점\n\n- 즉각적인 개발 서버 시작.\n- 최신 브라우저 환경 최적화.\n- 간단한 설정.\n\n### 단점\n\n- 플러그인 생태계의 제한: Rollup 기반 플러그인을 사용해야 함.\n- 복잡한 트랜스파일링이 필요한 경우 Babel 대비 기능 부족.\n\n---\n\n## Babel과 Esbuild: Transpiler 비교\n\n**트랜스파일러(Transpiler)**는 자바스크립트 코드를 다른 형식으로 변환하는 도구로, **최신 문법**을 구버전 브라우저에서 실행할 수 있도록 변환하거나, TypeScript를 JavaScript로 변환하는 데 사용됩니다.\n\n### Babel\n\n**Babel**은 주로 **최신 ECMAScript** 문법을 구버전 자바스크립트로 변환하거나, **TypeScript**를 JavaScript로 변환하는 데 사용됩니다. Babel은 매우 **유연한 설정**을 제공하며, 다양한 플러그인과 설정을 통해 사용자가 원하는 형태로 코드를 변환할 수 있습니다. 하지만 Babel은 **빌드 속도**가 느리다는 단점이 있습니다.\n\n### Esbuild\n\n**Esbuild**는 **Go 언어로 작성된** 트랜스파일러로, **Babel보다 훨씬 빠른 성능**을 자랑합니다. Esbuild는 최신 ECMAScript 문법을 구버전 브라우저에 맞게 변환하거나, TypeScript를 자바스크립트로 트랜스파일하는 작업을 매우 빠르게 처리할 수 있습니다. 그러나 **기능이 Babel보다 간단**하므로, 고급 기능이 필요할 경우 Babel을 사용하는 것이 좋습니다.\n\n> https://wndgur2.github.io/post/Babel_Esbuild\n\n## 빌드 속도 개선을 위한 Vite와 Esbuild Migration\n\n현재 빌드 속도를 향상시키기 위해 CRA에서 **Vite**와 **Esbuild** 환경으로 마이그레이션하는 방법을 고려하고 있습니다. Vite는 **빠른 개발 환경**을 제공하며, **Esbuild**는 빌드 속도가 빠르고 트랜스파일링 성능이 뛰어납니다. 이 두 가지 도구는 프로젝트의 빌드 속도를 획기적으로 개선할 수 있는 좋은 선택입니다.\n\n또한, **CRA(Create React App)** 프로젝트에서는 Webpack을 기본 번들러로 사용하지만, 설정 변경이 제한적입니다. 이를 해결하기 위해 **CRACO(Create React App Configuration Override)**를 사용해 Webpack 설정을 오버라이드할 수 있습니다.\nCRACO는 CRA 프로젝트의 **구성 파일을 쉽게 오버라이드**할 수 있도록 도와주는 도구입니다. 이를 통해 Webpack 설정을 수정할 수 있으며, **경로 별칭을 설정**하거나 추가적인 기능을 구현할 수 있습니다.\n\n### 마이그레이션의 이점\n\n1. **빠른 빌드 시간**: Esbuild와 Vite의 조합으로 빌드 속도가 크게 향상.\n2. **간단한 설정**: Vite는 기본적으로 사전 구성된 최적화 설정 제공.\n\n## 결론\n\nWebpack과 Vite는 각각의 장단점이 뚜렷한 도구입니다. Webpack은 복잡한 애플리케이션에 적합하며, Vite는 빠른 개발 환경을 제공합니다. 프로젝트 요구사항에 따라 적절한 도구를 선택하거나, 트랜스파일러(Babel/Esbuild)를 조합해 최적의 개발 환경을 구축하는 것이 중요합니다.\n\n---\n\n### 참고\n\n- https://webpack.js.org/\n- https://vite.dev/\n",
    "tags": [
      "browser",
      "bundler"
    ],
    "date_started": "2024.12.04",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/study/webpack_vite.md",
    "preview": ""
  },
  {
    "id": "posts/algorithm/가장_긴_증가하는_부분_수열_5.md",
    "category": "Algorithm",
    "title": "가장 긴 증가하는 부분 수열 5",
    "content": "# [백준 14003. 가장 긴 증가하는 부분 수열 5](https://www.acmicpc.net/problem/14003)\n\n## 문제\n\n수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.\n\n예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {10, 20, 10, 30, 20, 50} 이고, 길이는 4이다.\n\n## 입력\n첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다.\n\n둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (-1,000,000,000 ≤ Ai ≤ 1,000,000,000)\n\n## 출력\n첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.\n\n둘째 줄에는 정답이 될 수 있는 가장 긴 증가하는 부분 수열을 출력한다.\n\n## 예제 입력 1\n6\n10 20 10 30 20 50\n\n## 예제 출력 1\n4\n10 20 30 50\n\n## 풀이\n\nLIS(Longest Increasing Sequence)의 이진탐색을 활용한 기본적인 풀이는 아래와 같다. (LIS 길이 & 부분 수열 출력)\n\n먼저 LIS를 구하기 위해 사용되는 두 배열, DP 배열과 indexes 배열의 의미는 다음과 같다.\n\n이를 만드는 과정은 그 아래에서 보자.\n\n### DP 배열\nDP[i]: DP[i]를 마지막 원소로하여 형성할 수 있는 가장 긴 LIS의 길이는 i+1이다.\n\nex) input = [1, 2, 3, 2, 5]  \n    -> DP = [1, 2, 3, 5]\n\n### indexes 배열\nindexes[i]: i번째 입력이 DP에 삽입된 위치\n\nex) input = [1, 2, 3, 2, 5]  \n    -> indexes = [0, 1, 2, 1, 3]\n\n이제 형성 과정을 보자\n\n### 아이디어\n DP에 입력된 수를 넣으며 정렬된 배열로 유지한다. 정렬된 배열이기 때문에 이진탐색으로 통해 다음 수를 삽입할 위치를 빠르게 찾을 수 있고, 그 위치가 LIS의 길이와 관련이 있다.\n\n### 배열 형성 과정\n\n1. 주어진 수열을 순회하며 정렬이 유지된 DP 배열에 삽입한다.\n    > 이때 DP 배열은 정렬을 유지하므로 이진탐색을 통해 O(logN)에 삽입이 가능하다.\n2. 해당 수가 이미 DP 배열에 존재한다면 교체한다. (= 삽입하지 않는다.)\n3. 삽입된 자리를 indexes 배열에 저장한다.\n    > 부분 수열을 출력하기 위함 (역추적)\n\n필요한 배열을 모두 완성했다.\n\nDP 배열과 indexes 배열의 의미는 다음과 같다.\n\nDP는 이제 별 의미가 없다. 다만, DP의 크기가 LIS의 길이가 된다. 이는 indexes 원소들 중 최댓값 *(+1)* 이기도 하다.\n\nindexes는 해당 수가 삽입된 위치이다. 이를 거꾸로 순회한다면, LIS(순열)을 찾을 수 있다.\n\nLIS를 찾는 과정은 아래와 같다.\n\n### LIS 탐색 과정\n\n1. 우리는 LIS의 길이를 이미 알고 있다. 이를 l이라 하자.\n2. indexes에서 값이 l-1인, 즉, LIS의 마지막 수가 되는 값부터 찾는다.\n3. 찾았다면 그 앞 수, indexes에서 값이 l-2인 값을 찾는다.\n4. l개 원소를 찾을 때까지 반복한다.\n\n이로써 LIS 원소를 역순으로 수집했으니, 이를 다시 역순으로 출력해주면 된다.\n\n## 풀이 시 주의해야할 점\n\n**배열 형성 과정**에서 DP 배열에 입력하고자 하는 수가 존재할 때(2번) 교체한(혹은 삽입하지 않는)다고 했다. 이때, DP 배열에 변화가 없다고 하더라도 **indexes**에는 그 자리를 저장해야한다.\n\n당연한 과정인데 LIS 구현에 급급하다면 놓칠 수 있는 부분이라고 생각한다.\n\n사실 LIS 풀이 자체는 다른 블로그에 많이 올라와있지만 이 부분을 다룬 글이 없어 많이 헤매었고, 글을 작성하게 되었다.\n\n백준 기준으로 82%에서 '틀렸습니다'가 나온다면 이 문제일 것\n\n여기에 해당하는 반례는 아래와 같다.\n\ninput  \n> 4  \n0 2 2 1\n\nans  \n> 2  \n0 1\n\n---\n\n### Code\n\n<!-- CODE-APPENDED:Main.java -->\n```java\npackage BOJ.boj_14003;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    public static void main(String[] args) throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int N = Integer.parseInt(br.readLine());\n        int[] numbers = new int[N];\n        int[] indexes = new int[N];\n        ArrayList<Integer> LIS = new ArrayList<>();\n\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        for(int i=0; i<N; i++){\n            numbers[i] = Integer.parseInt(st.nextToken());\n        }\n\n        for(int i=0; i<N; i++){\n            int idx = (-Collections.binarySearch(LIS, numbers[i]) -1);\n            // System.out.println(idx);\n            // System.out.println(\"idx:\" + idx + \", LIS.size(): \" + LIS.size());\n            if(idx<0) {\n                indexes[i] = -idx-1;\n            } else if(idx>= LIS.size()){\n                indexes[i] = LIS.size();\n                LIS.add(numbers[i]);\n            } else{\n                indexes[i] = idx;\n                LIS.set(idx, numbers[i]);\n            }\n        }\n\n        // System.out.println(LIS);\n        // System.out.println(Arrays.toString(indexes));\n        int curIdx = LIS.size()-1;\n        ArrayDeque<Integer> stack = new ArrayDeque<>(); \n        for(int i=N-1; i>=0; i--){\n            if(indexes[i] == curIdx){\n                curIdx--;\n                stack.addFirst(numbers[i]);\n                if(curIdx==-1) break;\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n        sb.append(LIS.size()).append(\"\\n\");\n        while(!stack.isEmpty())sb.append(stack.pop() + \" \");\n        System.out.println(sb.toString().trim());\n    }\n}\n\n```\n",
    "tags": [
      "LIS",
      "java"
    ],
    "date_started": "2024.10.25",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/algorithm/%EA%B0%80%EC%9E%A5_%EA%B8%B4_%EC%A6%9D%EA%B0%80%ED%95%98%EB%8A%94_%EB%B6%80%EB%B6%84_%EC%88%98%EC%97%B4_5.md",
    "preview": ""
  },
  {
    "id": "posts/study/json_web_token.md",
    "category": "Study",
    "title": "JWT(Json Web Token)",
    "content": "\n<img width=\"1440\" alt=\"image\" src=\"https://github.com/user-attachments/assets/c5361105-709b-4404-96f8-64aa25557936\">\n\n\n# JWT(Json Web Token)\n\n> 쿠키 인증 기법\n\n1. 클라이언트가 로그인에 성공하면, 서버는 \\*_JWT를 만들어_ 클라이언트에게 송신한다.\n  - 로그인 정보, 로그인 정보를 비밀키로 암호화한 값(Signature), 해싱 방법, 만료 날짜를 묶은 JSON 데이터를 만든다. 이를 JWT라고 부른다.\n  - JWT에 담긴 payload는 누구나 조회할 수 있기때문에 비밀 정보는 담으면 안된다.\n  - 비밀키는 서버만 알아야 한다. 유효성 검사 시 다시 사용된다.\n\n2. 이후 클라이언트는 요청 시 해당 JWT를 입장권으로 사용한다.\n\n3. 서버는 수신한 JWT의 \\**유효성 검사*를 진행하여 Authenticate한다.\n  - _유효성 검사_(Validation): 수신한 JWT가 변조되었는지 확인한다.\n  - Payload를 암호화한 결과가 Signature와 여전히 일치하는지 확인한다.\n  - 만료 날짜가 지났는지 확인한다.\n",
    "tags": [
      "authentication",
      "jwt"
    ],
    "date_started": "2024.10.20",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/study/json_web_token.md",
    "preview": ""
  },
  {
    "id": "posts/algorithm/동전_0.md",
    "category": "Algorithm",
    "title": "동전 0",
    "content": "\n12:35~12:46\n\n문제\n준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다.\n\n동전을 적절히 사용해서 그 가치의 합을 K로 만들려고 한다. 이때 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하시오.\n\n입력\n첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 10, 1 ≤ K ≤ 100,000,000)\n\n둘째 줄부터 N개의 줄에 동전의 가치 Ai가 오름차순으로 주어진다. (1 ≤ Ai ≤ 1,000,000, A1 = 1, i ≥ 2인 경우에 Ai는 Ai-1의 배수)\n\n출력\n첫째 줄에 K원을 만드는데 필요한 동전 개수의 최솟값을 출력한다.\n\n> 그리디 문제의 핵심은, 그리디로 풀어도 된다는 것을 알아보는 것?\n\n---\n\n### Code\n\n<!-- CODE-APPENDED:Main.java -->\n```java\npackage BOJ.boj_11047;\n\nimport java.io.*;\n\npublic class Main{\n    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n    static StringBuilder sb = new StringBuilder();\n    public static void main(String[] args) throws IOException{\n        String[] N_COST = br.readLine().split(\" \");\n        int N = Integer.parseInt(N_COST[0]);\n        int cost = Integer.parseInt(N_COST[1]);\n        int[] units = new int[N];\n        while(N-->0){\n            units[N] = Integer.parseInt(br.readLine());\n        }\n        int currentCost = 0;\n        int idx=0, res = 0;\n        while(currentCost!=cost){\n            if(currentCost>cost){\n                currentCost-=units[idx++];\n                currentCost+=units[idx];\n            } else if(currentCost<cost){\n                currentCost+=units[idx];\n                res ++;\n            }\n        }\n        sb.append(res).append('\\n');\n        bw.write(sb.toString());\n        bw.flush();\n        bw.close();\n        br.close();\n    }\n}\n```\n",
    "tags": [
      "java",
      "그리디"
    ],
    "date_started": "2024.07.21",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/algorithm/%EB%8F%99%EC%A0%84_0.md",
    "preview": ""
  },
  {
    "id": "posts/algorithm/수_나누기_게임.md",
    "category": "Algorithm",
    "title": "수 나누기 게임",
    "content": "\n소요시간: 40분\n\n## 문제\n\n《보드게임컵》을 준비하다 지친 은하는 보드게임컵 참가자들을 경기장에 몰아넣고 결투를 시키는 게임 《수 나누기 게임》을 만들었습니다.\n\n《수 나누기 게임》의 규칙은 다음과 같습니다.\n\n게임을 시작하기 전 각 플레이어는  \n$1$부터  \n$1\\,000\\,000$ 사이의 수가 적힌 서로 다른 카드를 잘 섞은 뒤 한 장씩 나눠 가집니다.  \n매 턴마다 플레이어는 다른 플레이어와 한 번씩 결투를 합니다.  \n결투는 서로의 카드를 보여주는 방식으로 진행되며, 플레이어의 카드에 적힌 수로 다른 플레이어의 카드에 적힌 수를 나눴을 때, 나머지가  \n$0$이면 승리합니다. 플레이어의 카드에 적힌 수가 다른 플레이어의 카드에 적힌 수로 나누어 떨어지면 패배합니다. 둘 다 아니라면 무승부입니다.  \n승리한 플레이어는  \n$1$점을 획득하고, 패배한 플레이어는  \n$1$점을 잃습니다. 무승부인 경우 점수의 변화가 없습니다.  \n본인을 제외한 다른 모든 플레이어와 정확히 한 번씩 결투를 하고 나면 게임이 종료됩니다.  \n《수 나누기 게임》의 결과를 가지고 한별이와 내기를 하던 은하는 게임이 종료되기 전에 모든 플레이어의 점수를 미리 알 수 있을지 궁금해졌습니다. 은하를 위해 각 플레이어가 가지고 있는 카드에 적힌 수가 주어졌을 때, 게임이 종료된 후의 모든 플레이어의 점수를 구해주세요.\n\n## 입력\n\n첫 번째 줄에 플레이어의 수  \n$N$이 주어집니다.\n\n두 번째 줄에 첫 번째 플레이어부터  \n$N$번째 플레이어까지 각 플레이어가 가지고 있는 카드에 적힌 정수  \n$x_{1}$,  \n$\\cdots$,  \n$x_{N}$이 공백으로 구분되어 주어집니다.\n\n## 출력\n\n첫 번째 플레이어부터  \n$N$번째 플레이어까지 게임이 종료됐을 때의 각 플레이어의 점수를 공백으로 구분하여 출력해주세요.\n\n## 제한\n\n$2 \\le N \\le 100\\,000$   \n모든  \n$1 \\le i \\le N$에 대해  \n$1 \\le x_i \\le 1\\,000\\,000$입니다.  \n모든  \n$1 \\le i < j \\le N$에 대해  \n$x_i \\ne x_j$입니다. 즉, 어떤 수도  \n$x$에서 두 번 이상 등장하지 않습니다.  \n예제 입력 1  \n3  \n3 4 12  \n예제 출력 1  \n1 1 -2  \n예제 입력 2  \n4  \n7 23 8 6  \n예제 출력 2  \n0 0 0 0\n\n---\n\n### Code\n\n<!-- CODE-APPENDED:Main.java -->\n```java\npackage BOJ.boj_27172;\n\n// 12:45\n// 13:26\n/**\n * N < 100000\n * x < 1000000\n */\nimport java.io.*;\n\npublic class Main {\n    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n    static StringBuilder sb = new StringBuilder();\n\n    public static void main(String[] args) throws IOException{\n        int N = Integer.parseInt(br.readLine());\n        String[] cardsString = br.readLine().split(\" \");\n        int[] cards = new int[N];\n        int i=0, maxN=0;\n        for(String cardString: cardsString){\n            cards[i++] = Integer.parseInt(cardString);\n            if(cards[i-1] > maxN) maxN = cards[i-1];\n        }\n\n        int[] scores = new int[maxN+1];\n        boolean[] isPresent = new boolean[maxN+1];\n        for(int card:cards){\n            isPresent[card] = true;\n        }\n\n        for(i=0; i<N; i++){\n            for(int j=cards[i]*2; j<=maxN; j+=cards[i]){\n                // j가 cards에 있으면\n                if(isPresent[j]){\n                    scores[j]--;\n                    scores[cards[i]]++;\n                }\n                // System.out.println(Arrays.toString(scores));\n            }\n        }\n\n        for(int card:cards){\n            sb.append(scores[card]).append(' ');\n        }\n        bw.write(sb.toString() + '\\n');\n        bw.flush();\n        bw.close();\n        br.close();\n    }\n}\n\n```\n",
    "tags": [
      "java",
      "수학",
      "에라토스테네스의_체"
    ],
    "date_started": "2024.07.20",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/algorithm/%EC%88%98_%EB%82%98%EB%88%84%EA%B8%B0_%EA%B2%8C%EC%9E%84.md",
    "preview": ""
  },
  {
    "id": "posts/algorithm/소수의_연속합.md",
    "category": "Algorithm",
    "title": "소수의 연속합",
    "content": "\n소요시간: 27분\n\n# 문제\n\n하나 이상의 연속된 소수의 합으로 나타낼 수 있는 자연수들이 있다. 몇 가지 자연수의 예를 들어 보면 다음과 같다.\n\n3 : 3 (한 가지)\n41 : 2+3+5+7+11+13 = 11+13+17 = 41 (세 가지)\n53 : 5+7+11+13+17 = 53 (두 가지)\n하지만 연속된 소수의 합으로 나타낼 수 없는 자연수들도 있는데, 20이 그 예이다. 7+13을 계산하면 20이 되기는 하나 7과 13이 연속이 아니기에 적합한 표현이 아니다. 또한 한 소수는 반드시 한 번만 덧셈에 사용될 수 있기 때문에, 3+5+5+7과 같은 표현도 적합하지 않다.\n\n자연수가 주어졌을 때, 이 자연수를 연속된 소수의 합으로 나타낼 수 있는 경우의 수를 구하는 프로그램을 작성하시오.\n\n## 입력\n\n첫째 줄에 자연수 N이 주어진다. (1 ≤ N ≤ 4,000,000)\n\n## 출력\n\n첫째 줄에 자연수 N을 연속된 소수의 합으로 나타낼 수 있는 경우의 수를 출력한다.\n\n## 예제 입력 1\n\n20\n\n## 예제 출력 1\n\n0\n\n## 예제 입력 2\n\n3\n\n## 예제 출력 2\n\n1\n\n## 예제 입력 3\n\n41\n\n## 예제 출력 3\n\n3\n\n## 예제 입력 4\n\n53\n\n## 예제 출력 4\n\n2\n\n# 풀이\n\n### 에라토스테네스의체\n\n범위의 소수를 구할 때 사용하는 방법.  \nO(n(logn)(logn))이 걸린다.\n\n### 투 포인터\n\n위 방법으로 소수를 구해서 400만까지의 소수의 개수를 출력해보니, 28만개가 나왔다.  \n따라서 O(n\\*n)으로는 풀 수 없다고 생각했다.  \n연속된 소수의 합이라는 조건이 있어서 투 포인터로 시간을 줄일 수 있었다.  \n합치는 범위의 시작을 stIdx, 범위의 끝을 endIdx 변수로 유지했다.\n\n결국 문제 해결 시간복잡도는 에라토스테네스의체가 결정하기에 O(n(logn)(logn))이다.\n\n---\n\n### Code\n\n<!-- CODE-APPENDED:Main.java -->\n```java\npackage BOJ.boj_1644;\n\nimport java.io.*;\n\npublic class Main {\n    static final int MAX_N = 4000000;\n    static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n    static BufferedReader br = new BufferedReader((new InputStreamReader(System.in)));\n    static StringBuilder sb = new StringBuilder();\n    static boolean[] isNotPrime;\n\n    public static void main(String[] args) throws IOException {\n        int N = Integer.parseInt(br.readLine());\n        isNotPrime = getNotPrimes(N);\n        int stN = 2;\n        int endN = 2;\n        int curSum = 2;\n        int res = 0;\n        while(endN<=N && stN<=endN){\n            if(curSum == N) {\n                res++;\n                endN = getNextPrime(endN, N);\n                curSum += endN;\n            } else if(curSum < N){\n                endN = getNextPrime(endN, N);\n                curSum += endN;\n            } else if(curSum > N){\n                curSum -= stN;\n                stN = getNextPrime(stN, N);\n            }\n        }\n        sb.append(res).append('\\n');\n        bw.write(sb.toString());\n        bw.flush();\n        bw.close();\n        br.close();\n    }\n\n    static boolean[] getNotPrimes(int N){\n        boolean[] isNotPrime_ = new boolean[N+1];\n        isNotPrime_[0] = true;\n        isNotPrime_[1] = true;\n        for(int i=2; i<=N; i++){\n            if(isNotPrime_[i]) continue;\n            for(int j=i*2; j<=N; j+=i){\n                isNotPrime_[j] = true;\n            }\n        }\n\n        return isNotPrime_;\n    }\n\n    static int getNextPrime(int i, int N){\n        for(i++; i<=N; i++){\n            if(!isNotPrime[i]) return i;\n        }\n        return MAX_N+1;\n    }\n}\n\n```\n",
    "tags": [
      "java",
      "수학",
      "에라토스테네스의_체",
      "투포인터"
    ],
    "date_started": "2024.07.19",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/algorithm/%EC%86%8C%EC%88%98%EC%9D%98_%EC%97%B0%EC%86%8D%ED%95%A9.md",
    "preview": ""
  },
  {
    "id": "posts/algorithm/탑.md",
    "category": "Algorithm",
    "title": "탑",
    "content": "\n소요시간: 60분\n\n## 문제\n\nKOI 통신연구소는 레이저를 이용한 새로운 비밀 통신 시스템 개발을 위한 실험을 하고 있다. 실험을 위하여 일직선 위에 N개의 높이가 서로 다른 탑을 수평 직선의 왼쪽부터 오른쪽 방향으로 차례로 세우고, 각 탑의 꼭대기에 레이저 송신기를 설치하였다. 모든 탑의 레이저 송신기는 레이저 신호를 지표면과 평행하게 수평 직선의 왼쪽 방향으로 발사하고, 탑의 기둥 모두에는 레이저 신호를 수신하는 장치가 설치되어 있다. 하나의 탑에서 발사된 레이저 신호는 가장 먼저 만나는 단 하나의 탑에서만 수신이 가능하다.\n\n예를 들어 높이가 6, 9, 5, 7, 4인 다섯 개의 탑이 수평 직선에 일렬로 서 있고, 모든 탑에서는 주어진 탑 순서의 반대 방향(왼쪽 방향)으로 동시에 레이저 신호를 발사한다고 하자. 그러면, 높이가 4인 다섯 번째 탑에서 발사한 레이저 신호는 높이가 7인 네 번째 탑이 수신을 하고, 높이가 7인 네 번째 탑의 신호는 높이가 9인 두 번째 탑이, 높이가 5인 세 번째 탑의 신호도 높이가 9인 두 번째 탑이 수신을 한다. 높이가 9인 두 번째 탑과 높이가 6인 첫 번째 탑이 보낸 레이저 신호는 어떤 탑에서도 수신을 하지 못한다.\n\n탑들의 개수 N과 탑들의 높이가 주어질 때, 각각의 탑에서 발사한 레이저 신호를 어느 탑에서 수신하는지를 알아내는 프로그램을 작성하라.\n\n## 입력\n\n첫째 줄에 탑의 수를 나타내는 정수 N이 주어진다. N은 1 이상 500,000 이하이다. 둘째 줄에는 N개의 탑들의 높이가 직선상에 놓인 순서대로 하나의 빈칸을 사이에 두고 주어진다. 탑들의 높이는 1 이상 100,000,000 이하의 정수이다.\n\n## 출력\n\n첫째 줄에 주어진 탑들의 순서대로 각각의 탑들에서 발사한 레이저 신호를 수신한 탑들의 번호를 하나의 빈칸을 사이에 두고 출력한다. 만약 레이저 신호를 수신하는 탑이 존재하지 않으면 0을 출력한다.\n\n## 예제 입력 1\n\n5  \n6 9 5 7 4\n\n## 예제 출력 1\n\n0 0 2 2 4\n\n---\n\n### Code\n\n<!-- CODE-APPENDED:Main.java -->\n```java\npackage BOJ.boj_2493;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.LinkedList;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    static BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n\n    public static void main(String[] args) throws IOException {\n        bf.readLine();\n        System.out.println(solve());\n    }\n\n    private static String solve() throws IOException{\n        LinkedList<Integer> result = new LinkedList<>();\n        Stack<Building> stack = new Stack<>();\n\n        StringTokenizer stringTokenizer = new StringTokenizer(bf.readLine());\n\n        int index = 1;\n        while(stringTokenizer.hasMoreTokens()){\n            Building current_building = new Building(index, Integer.parseInt(stringTokenizer.nextToken()));\n            while(!stack.empty() && stack.peek().height < current_building.height){\n                stack.pop();\n            }\n            if(stack.empty()){\n                stack.push(current_building);\n                result.add(0);\n            } else {\n                result.add(stack.peek().index);\n                stack.push(current_building);\n            }\n            index ++;\n        }\n\n        return result.toString().replaceAll(\"[,\\\\[\\\\]]\", \"\");\n    }\n\n    static class Building{\n        int index;\n        int height;\n        Building(int index, int height){\n            this.index = index;\n            this.height = height;\n        }\n    }\n}\n\n```\n",
    "tags": [
      "java",
      "스택"
    ],
    "date_started": "2024.07.18",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/algorithm/%ED%83%91.md",
    "preview": ""
  },
  {
    "id": "posts/algorithm/에라토스테네스의체.md",
    "category": "Algorithm",
    "title": "에라토스테네스의체",
    "content": "\n## 문제\n\n에라토스테네스의체는 N보다 작거나 같은 모든 소수를 찾는 유명한 알고리즘이다.\n\n이 알고리즘은 다음과 같다.\n\n2부터 N까지 모든 정수를 적는다.\n아직 지우지 않은 수 중 가장 작은 수를 찾는다. 이것을 P라고 하고, 이 수는 소수이다.\nP를 지우고, 아직 지우지 않은 P의 배수를 크기 순서대로 지운다.\n아직 모든 수를 지우지 않았다면, 다시 2번 단계로 간다.\nN, K가 주어졌을 때, K번째 지우는 수를 구하는 프로그램을 작성하시오.\n\n## 입력\n\n첫째 줄에 N과 K가 주어진다. (1 ≤ K < N, max(1, K) < N ≤ 1000)\n\n## 출력\n\n첫째 줄에 K번째 지워진 수를 출력한다.\n\n## 예제 입력 1\n\n7 3\n\n## 예제 출력 1\n\n6\n\n## 예제 입력 2\n\n15 12\n\n## 예제 출력 2\n\n7\n\n## 예제 입력 3\n\n10 7\n\n## 예제 출력 3\n\n9\n\n2, 4, 6, 8, 10, 3, 9, 5, 7 순서대로 지워진다. 7번째 지워진 수는 9이다.\n\n### 풀이\n\n에라토스테네스의체 구현.\n\n각 소수의 n배수는 소수가 아니라는 점을 활용한다.\n\n---\n\n### Code\n\n<!-- CODE-APPENDED:Main.java -->\n```java\npackage BOJ.boj_2960;\n\nimport java.io.*;\n\npublic class Main {\n    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    public static void main(String[] args) throws IOException {\n        String[] NK = br.readLine().split(\" \");\n        int N = Integer.parseInt(NK[0]);\n        int K = Integer.parseInt(NK[1]);\n        boolean[] isErased = new boolean[N+1];\n        int erasedN = 0;\n\n        for(int i=2; i<=N; ++i){\n            for(int j=i; j<=N; j+=i){\n                if(!isErased[j]){\n                    isErased[j] = true;\n                    erasedN ++;\n                    if(erasedN == K){\n                        System.out.println(j);\n                        return;\n                    }\n                }\n            }\n        }\n    }\n}\n\n```\n",
    "tags": [
      "java",
      "수학",
      "에라토스테네스의_체"
    ],
    "date_started": "2024.07.18",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/algorithm/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98%EC%B2%B4.md",
    "preview": ""
  },
  {
    "id": "posts/algorithm/소수_구하기.md",
    "category": "Algorithm",
    "title": "소수 구하기",
    "content": "\n## 문제\n\nM이상 N이하의 소수를 모두 출력하는 프로그램을 작성하시오.\n\n## 입력\n\n첫째 줄에 자연수 M과 N이 빈 칸을 사이에 두고 주어진다. (1 ≤ M ≤ N ≤ 1,000,000) M이상 N이하의 소수가 하나 이상 있는 입력만 주어진다.\n\n## 출력\n\n한 줄에 하나씩, 증가하는 순서대로 소수를 출력한다.\n\n## 예제 입력 1\n\n3 16\n\n## 예제 출력 1\n\n3  \n5  \n7  \n11  \n13\n\n---\n\n### Code\n\n<!-- CODE-APPENDED:Main.java -->\n```java\npackage BOJ.boj_1929;\n\nimport java.io.*;\nimport java.util.Arrays;\n\npublic class Main {\n    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n    static StringBuilder sb = new StringBuilder();\n\n    public static void main(String[] args)throws IOException {\n        String[] MN = br.readLine().split(\" \");\n        int M = Integer.parseInt(MN[0]);\n        int N = Integer.parseInt(MN[1]);\n        boolean[] isPrime = new boolean[N+1];\n        Arrays.fill(isPrime, true);\n        isPrime[0]=false;\n        isPrime[1]=false;\n        for (int i = 2; i < N; i++) {\n            for(int j=i*2; j<=N; j+=i){\n                isPrime[j] = false;\n            }\n        }\n        for(int i=M; i<=N; i++){\n            if(isPrime[i])\n                sb.append(i).append('\\n');\n        }\n        bw.write(sb.toString());\n        bw.flush();\n        bw.close();\n        br.close();\n    }\n}\n\n```\n",
    "tags": [
      "java",
      "수학",
      "에라토스테네스의_체"
    ],
    "date_started": "2024.07.18",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/algorithm/%EC%86%8C%EC%88%98_%EA%B5%AC%ED%95%98%EA%B8%B0.md",
    "preview": ""
  },
  {
    "id": "posts/algorithm/파핑파핑_지뢰찾기.md",
    "category": "Algorithm",
    "title": "파핑파핑 지뢰찾기",
    "content": "\n소요시간 1시간\n\n## 구현\n\nBufferedReader에 이어 BufferedWriter를 써봤다.  \nflush();를 해야만 했다.\n\n---\n\n### Code\n\n<!-- CODE-APPENDED:Solution.java -->\n```java\npackage SWEA.swea_1868;\nimport java.io.*;\nimport java.util.*;\n\nclass Solution\n{\n    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n    static int[][] dirs = {{1,0},{1,1},{1,-1},{0,1},{0,-1},{-1,1},{-1,0},{-1,-1}};\n\n    public static void main(String args[]) throws Exception\n    {\n        int T;\n        T=Integer.parseInt(br.readLine());\n\n        for(int test_case = 1; test_case <= T; test_case++)\n        {\n            bw.write(\"#\" + Integer.toString(test_case) + \" \");\n            new Solution().solve();\n        }\n\n        br.close();\n        bw.flush();\n        bw.close();\n    }\n\n    ArrayList<char[]> mapVision= new ArrayList<>();\n    int SIZE;\n    int answer=0;\n\n    public void solve() throws IOException{\n        this.SIZE = Integer.parseInt(br.readLine());\n        char[] tmp;\n\n        for(int i=0; i<SIZE; i++){\n            tmp = br.readLine().toCharArray();\n            mapVision.add(tmp);\n        }\n\n        // fill nums\n        for(int i=0; i<SIZE; i++) {\n            for(int j=0; j<SIZE; j++) {\n                if (mapVision.get(i)[j] == '.') {\n                    int bombN = new Coord(i, j).getBombN();\n                    mapVision.get(i)[j] = Character.forDigit(bombN, 10);\n                }\n            }\n        }\n\n        // 영역의 개수 세기\n        for(int i=0; i<SIZE; i++) {\n            for (int j = 0; j < SIZE; j++) {\n                Coord coord = new Coord(i, j);\n                if(coord.getValue() == '0'){\n                    answer++;\n                    coord.fillArea();\n                }\n            }\n        }\n        for(int i=0; i<SIZE; i++) {\n            for (int j = 0; j < SIZE; j++) {\n                Coord coord = new Coord(i, j);\n                if(coord.getValue() != '*' && coord.getValue() != 'V'){\n                    answer++;\n                    coord.fillArea();\n                }\n            }\n        }\n\n        bw.write(Integer.toString(answer)+'\\n');\n    }\n\n    public class Coord{\n        int y, x;\n        public Coord(int y, int x){\n            this.y = y;\n            this.x = x;\n        }\n\n        boolean isValidate(){\n            return y >= 0 && y < Solution.this.SIZE && x >= 0 && x < Solution.this.SIZE;\n        }\n\n        char getValue(){\n            return Solution.this.mapVision.get(this.y)[this.x];\n        }\n\n        void setValue(char c){\n            Solution.this.mapVision.get(this.y)[this.x] = c;\n        }\n\n        int getBombN(){\n            int res = 0;\n            for (int dIndex = 0; dIndex < 8; dIndex++) {\n                Coord newCoord = new Coord(this.y+dirs[dIndex][0], this.x+dirs[dIndex][1]);\n                if(!newCoord.isValidate()) continue;\n                if(newCoord.getValue()=='*') res++;\n            }\n            return res;\n        }\n\n        void fillArea(){\n            if(getValue()=='V') return;\n            if(getValue()!='0') {\n                setValue('V');\n                return;\n            }\n            setValue('V');\n            for (int dIndex = 0; dIndex < 8; dIndex++) {\n                Coord newCoord = new Coord(this.y+dirs[dIndex][0], this.x+dirs[dIndex][1]);\n                if(!newCoord.isValidate()) continue;\n                if(newCoord.getValue()!='*') newCoord.fillArea();\n            }\n        }\n    }\n}\n\n```\n",
    "tags": [
      "java",
      "구현"
    ],
    "date_started": "2024.07.15",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/algorithm/%ED%8C%8C%ED%95%91%ED%8C%8C%ED%95%91_%EC%A7%80%EB%A2%B0%EC%B0%BE%EA%B8%B0.md",
    "preview": ""
  },
  {
    "id": "posts/algorithm/수영대회_결승전.md",
    "category": "Algorithm",
    "title": "수영대회 결승전",
    "content": "\n18:10~ 19:15\n\n시간초과. 제자리에 머무르는 경우가, 소용돌이를 기다릴 때밖에 없다는 것을 알았고, 그렇게 하지 않으면 계속 기다리는 경우때문에 시간초과에 걸림.\n아직 이차원 배열을 자유롭게 다루지 못하고 있음. (시간이 너무 오래 걸림)\n\n## 완전탐색\n\n---\n\n### Code\n\n<!-- CODE-APPENDED:Solution.java -->\n```java\npackage SWEA.swea_4193;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.StringTokenizer;\n\npublic class Solution {\n    static BufferedReader bf;\n    final static int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\n    public static void main(String[] args) throws IOException{\n        bf = new BufferedReader(new InputStreamReader(System.in));\n        int T = Integer.parseInt(bf.readLine());\n        for(int t=1; t<=T; t++){\n            new Solution().solve(t);\n        }\n    }\n\n    ArrayList<ArrayList<Integer>> map;\n    ArrayList<ArrayList<Boolean>> visited;\n\n    public void solve(int t) throws IOException{\n        System.out.print(\"#\" + Integer.toString(t) + \" \");\n        final int SIZE = Integer.parseInt(bf.readLine());\n\n        // System.out.println(SIZE);\n\n        // map\n        this.map = new ArrayList<>();\n        this.visited = new ArrayList<>();\n        for(int row=0; row<SIZE; row++){\n            map.add(new ArrayList<>());\n            visited.add(new ArrayList<>());\n            StringTokenizer st = new StringTokenizer(bf.readLine());\n            while(st.hasMoreTokens()){\n                map.get(row).add(Integer.parseInt(st.nextToken()));\n                visited.get(row).add(false);\n            }\n        }\n\n        // System.out.println(map);\n\n        StringTokenizer st = new StringTokenizer(bf.readLine());\n        Coordinate startCoord = new Coordinate(Integer.parseInt(st.nextToken()), Integer.parseInt(st.nextToken()));\n        st = new StringTokenizer(bf.readLine());\n        Coordinate endCoord = new Coordinate(Integer.parseInt(st.nextToken()), Integer.parseInt(st.nextToken()));\n        \n        Branch branch;\n        LinkedList<Branch> queue = new LinkedList<>();\n        queue.add(new Branch(startCoord, 0));\n        while(!queue.isEmpty()){\n            branch = queue.pop();\n            if(branch.coord.equals(endCoord)){\n                System.out.println(branch.depth);\n                return;\n            }\n            if(branch.coord.isVisited()) continue;\n            branch.coord.visit();\n\n            if((branch.depth+1)%3!=0){\n                this.visited.get(branch.coord.y).set(branch.coord.x, false);\n                queue.add(new Branch(new Coordinate(branch.coord.y, branch.coord.x), branch.depth+1));\n            }\n            \n            for(int i=0; i<4; i++){\n                int newY = branch.coord.y + Solution.dirs[i][0];\n                int newX = branch.coord.x + Solution.dirs[i][1];\n                Coordinate newCoord = new Coordinate(newY, newX);\n\n                // 범위\n                if(newY<0 || newY>=SIZE || newX<0 || newX>=SIZE) continue;\n                \n                // 장애물\n                int newValue = map.get(newY).get(newX);\n                if(newValue == 1 || (newValue==2 && ((branch.depth+1)%3!=0))) continue;\n                \n                // visited\n                if(newCoord.isVisited()) continue;\n\n                queue.add(new Branch(newCoord, branch.depth+1));\n            }\n        }\n        System.out.println(-1);\n    }\n\n    public class Coordinate{\n        public int y;\n        public int x;\n\n        Coordinate(int y, int x){\n            this.y = y;\n            this.x = x;\n        }\n        \n        public int getValue(){\n            return Solution.this.map.get(this.y).get(this.x);\n        }\n\n        public void visit(){\n            Solution.this.visited.get(this.y).set(this.x, true);\n        }\n\n        public boolean isVisited(){\n            return Solution.this.visited.get(this.y).get(this.x);\n        }\n\n        public boolean equals(Coordinate coord){\n            if(this.y == coord.y && this.x == coord.x) return true;\n            else return false;\n        }\n    }\n\n    public class Branch{\n        Coordinate coord;\n        int depth;\n        Branch(Coordinate coord, int depth){\n            this.coord = coord;\n            this.depth = depth;\n        }\n    }\n}\n\n```\n",
    "tags": [
      "java",
      "완전탐색"
    ],
    "date_started": "2024.07.14",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/algorithm/%EC%88%98%EC%98%81%EB%8C%80%ED%9A%8C_%EA%B2%B0%EC%8A%B9%EC%A0%84.md",
    "preview": ""
  },
  {
    "id": "posts/algorithm/Ladder1.md",
    "category": "Algorithm",
    "title": "Ladder1",
    "content": "\n## 구현\n\n소요시간 48분\n\nJAVA 알고리즘 세 번째 문제  \n이차원 배열을 다루어보았다.\n입력 받을 때, Stream.toList()를 사용하려 했으나, 이는 jdk8버전에서는 없는 함수였기에,\nStringTokenizer로 각각 추가해주었다.\n\n문제 풀이는 단순 구현이었다.\n\n---\n\n### Code\n\n<!-- CODE-APPENDED:Solution.java -->\n```java\npackage SWEA.swea_1210;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.FileInputStream;\nimport java.util.*;\n\n\npublic class Solution {\n    static BufferedReader bf;\n    static final int size = 100;\n    public static void main(String[] args) throws IOException{\n        System.setIn(new FileInputStream(\"./input.txt\"));\n        bf = new BufferedReader(new InputStreamReader(System.in));\n\n        for(int T = 1; T<=10; T++){\n            new Solution().solve(T);\n        }\n    }\n\n    public int x, y;\n    public boolean movedLeft, movedRight;\n    \n    public void solve(int T) throws IOException{\n        System.out.print(\"#\" + T + ' ');\n        Solution.bf.readLine();\n        ArrayList<ArrayList<Integer>> map = new ArrayList<>();\n        for(int line=0; line<Solution.size; ++line){\n            map.add(new ArrayList<>());\n            StringTokenizer st = new StringTokenizer(bf.readLine());\n            int idx = 0;\n            while(st.hasMoreTokens()){\n                int tmp = Integer.parseInt(st.nextToken());\n                map.get(line).add(tmp);\n                if(tmp==2){\n                    this.x = idx;\n                    this.y = line;\n                }\n                idx++;\n            }\n        }\n\n        while(this.y > 0){\n            // System.out.println(Integer.toString(x) + ' ' + Integer.toString(y));\n            if(!movedLeft && this.x<Solution.size-1 && map.get(this.y).get(this.x+1) == 1){ // 오른쪽\n                this.x++;\n                this.movedLeft = false;\n                this.movedRight = true;\n            } else if(!movedRight && this.x>0 && map.get(this.y).get(this.x-1) == 1){ //왼쪽\n                this.x--;\n                this.movedRight = false;\n                this.movedLeft = true;\n            } else{\n                this.y--;\n                this.movedRight = false;\n                this.movedLeft = false;\n            }\n        }\n\n        System.out.println(this.x);\n    }\n}\n\n```\n",
    "tags": [
      "java",
      "구현"
    ],
    "date_started": "2024.07.14",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/algorithm/Ladder1.md",
    "preview": ""
  },
  {
    "id": "posts/algorithm/Flatten.md",
    "category": "Algorithm",
    "title": "Flatten",
    "content": "\nFlatten\n\n소요시간 50분\n\nSWEA 첫 자바 풀이였다.\ninput 스트림 연결, class명, static 변수 사용 등을 익혔다.\n\n문제 풀이 자체는 어렵지 않았다.\n\n그런데 더 좋은 풀이가 있었다.\n\n나는 박스들의 높이를 정렬한 후 높은 박스를 하나씩 내려주는 방식으로 풀이했고,\n\n가장 짧은 실행시간의 코드를 보니, 박스의 높이를 index로 하는 배열을 썼다.\n\n왜 이걸 생각 못했나 했고, 앞으론 변수의 범위를 잘 보고, 배열의 index로 쓸 수 있는지 확인해야겠다.\n\n---\n\n### Code\n\n<!-- CODE-APPENDED:Solution.java -->\n```java\npackage SWEA.swea_1208;\n\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\npublic class Solution {\n    static BufferedReader bufferedReader;\n\n    static ArrayList<Integer> boxHeights;\n    static int minIndex;\n    public static void main(String[] args) throws IOException {\n        System.setIn(new FileInputStream(\"./input.txt\"));\n        bufferedReader = new BufferedReader(new InputStreamReader(System.in));\n\n        for(int i=0; i<10; ++i){\n            System.out.print(\"#\" + (i + 1) + ' ');\n            solve();\n        }\n    }\n\n    static void solve() throws IOException{\n        int maxDumpN = Integer.parseInt(bufferedReader.readLine());\n//        System.out.println(maxDumpN);\n        StringTokenizer boxHeightsTokens = new StringTokenizer(bufferedReader.readLine());\n\n        boxHeights = new ArrayList<>();\n        while(boxHeightsTokens.hasMoreTokens()){\n            int height = Integer.parseInt(boxHeightsTokens.nextToken());\n//            System.out.print(Integer.toString(height) + ' ');\n            boxHeights.add(height);\n        }\n//        System.out.println();\n        boxHeights.sort((o1, o2) -> o1>o2?-1: o1.equals(o2)? 0:1);\n        minIndex = boxHeights.size()-1;\n\n        int dumpedN = 0;\n        int index = 0;\n        int curHeight = boxHeights.get(0);\n        while(dumpedN < maxDumpN && index < minIndex && boxHeights.get(index) > boxHeights.get(minIndex)){\n            if(boxHeights.get(index) == curHeight){\n                dump(index);\n                dumpedN++;\n                index++;\n            } else{\n                index = 0;\n                curHeight = boxHeights.get(0);\n            }\n        }\n\n        System.out.println(boxHeights.get(index)-boxHeights.get(minIndex));\n    }\n\n    static void dump(int index){\n        boxHeights.set(index, boxHeights.get(index)-1);\n        int minHeight = boxHeights.get(minIndex);\n        boxHeights.set(minIndex, boxHeights.get(minIndex)+1);\n        minIndex--;\n        if(boxHeights.get(minIndex) != minHeight){\n            minIndex = boxHeights.size()-1;\n        }\n    }\n}\n\n```\n",
    "tags": [
      "java",
      "구현"
    ],
    "date_started": "2024.07.13",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/algorithm/Flatten.md",
    "preview": ""
  },
  {
    "id": "posts/algorithm/전기버스.md",
    "category": "Algorithm",
    "title": "전기버스",
    "content": "\n### 구현, 그리디\n\n---\n\n### Code\n\n<!-- CODE-APPENDED:4831_전기버스.py -->\n```python\n\"\"\"\n\t4831_전기버스 created at 2024-07-07-11:07:12\n\n    8분 소요\n\"\"\"\n\nimport sys\nsys.stdin = open(\"input.txt\", \"r\")\n\nfor test_case in range(1, int(input()) + 1):\n    K, N, M = map(int, input().split())\n    stations = list(map(int, input().split()))\n    stations.sort()\n\n    charged_N = 0\n    cur_loc = 0\n    for i in range(len(stations)):\n        if stations[i]-cur_loc > K:\n            charged_N = 0\n            break\n        if i<M-1 and stations[i+1]-cur_loc <= K:\n            continue\n        if i==M-1 and N-cur_loc <= K:\n            continue\n\n        charged_N += 1\n        cur_loc = stations[i]\n            \n    print(f'#{test_case} {charged_N}')\n```\n",
    "tags": [
      "python",
      "구현",
      "그리디"
    ],
    "date_started": "2024.07.07",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/algorithm/%EC%A0%84%EA%B8%B0%EB%B2%84%EC%8A%A4.md",
    "preview": ""
  },
  {
    "id": "posts/algorithm/두개의_숫자열.md",
    "category": "Algorithm",
    "title": "두개의 숫자열",
    "content": "\n### #구현\n\n---\n\n### Code\n\n<!-- CODE-APPENDED:1959_두개의숫자열.py -->\n```python\n\"\"\"\n\t1959_두개의숫자열 created at 2024-07-06-22:34:49\n    \n    통과 22:45\n\n    소요 시간 11분\n\"\"\"\n\nimport sys\nsys.stdin = open(\"input.txt\", \"r\")\n\nfor test_case in range(1, int(input()) + 1):\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    \n    BIG = A if len(A) > len(B) else B\n    SMALL = A if len(B) > len(A) else B\n\n    DIF = len(BIG) - len(SMALL)\n\n    result = -123456789\n    \n    for i in range(DIF+1):\n        tmp = 0\n        for j in range(len(SMALL)):\n            tmp += SMALL[j] * BIG[i + j]\n        result = tmp if tmp > result else result\n\n    print(f'#{test_case} {result}')\n```\n",
    "tags": [
      "python",
      "구현"
    ],
    "date_started": "2024.07.06",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/algorithm/%EB%91%90%EA%B0%9C%EC%9D%98_%EC%88%AB%EC%9E%90%EC%97%B4.md",
    "preview": ""
  },
  {
    "id": "posts/algorithm/파리퇴치.md",
    "category": "Algorithm",
    "title": "파리퇴치",
    "content": "\n## 12712\\_파리퇴치 2024-07-04-18:31:07\n\n### #구현\n\n| 입력 예         |\n| --------------- |\n| 2               |\n| 5 2             |\n| 1 3 3 6 7       |\n| 8 13 9 12 8     |\n| 4 16 11 12 6    |\n| 2 4 1 23 2      |\n| 9 13 4 7 3      |\n| 6 3             |\n| 29 21 26 9 5 8  |\n| 21 19 8 0 21 19 |\n| 9 24 2 11 4 24  |\n| 19 29 1 0 21 19 |\n| 10 29 6 18 4 3  |\n| 29 11 15 3 3 29 |\n\n| 출력 예 |\n| ------- |\n| #1      |\n| 64      |\n| #2      |\n| 157     |\n\n---\n\n### Code\n\n<!-- CODE-APPENDED:12712_파리퇴치.py -->\n```python\n\"\"\"\n\n\t12712_파리퇴치 created at 2024-07-04-18:31:07\n\n    1. N 은 5 이상 15 이하이다.\n    2. M은 2 이상 N 이하이다.\n    3. 각 영역의 파리 갯수는 30 이하 이다.\n\n\"\"\"\n\nimport sys\nsys.stdin = open(\"input.txt\", \"r\")\n\nglobal flies, N, M\n\ndef getKillableFlies(y, x):\n    numOfFliesA = 0\n    numOfFliesB = 0\n\n    # +\n    # row\n    stX = x-(M-1) if x-(M-1)>=0 else 0\n    endX = x+(M-1) if x+(M-1)<N else N-1\n    numOfFliesA += sum([_ for _ in flies[y][stX:endX+1]])\n\n    # col\n    stY = y-(M-1) if y-(M-1)>=0 else 0\n    endY = y+(M-1) if y+(M-1)<N else N-1\n    for tmp_y in range(stY, endY+1):\n        numOfFliesA += flies[tmp_y][x]\n        \n    numOfFliesA -= flies[y][x]\n\n    # x\n    # \\\n    stX = x\n    stY = y\n    for i in range(M):\n        if x-i < 0:\n            break\n        if y-i < 0:\n            break\n        stX = x-i\n        stY = y-i\n\n    for i in range(M*2-1):\n        if stX+i >= N:\n            break\n        if stY+i >= N:\n            break\n        numOfFliesB += flies[stY+i][stX+i]\n\n    # /\n    stX = x\n    stY = y\n    for i in range(M):\n        if x-i < 0:\n            break\n        if y+i >= N:\n            break\n        stX = x-i\n        stY = y+i\n\n    for i in range(M*2-1):\n        if stX+i >= N:\n            break\n        if stY-i < 0:\n            break\n        numOfFliesB += flies[stY-i][stX+i]\n\n    numOfFliesB -= flies[y][x]\n\n    return numOfFliesA if numOfFliesA > numOfFliesB else numOfFliesB\n\nfor test_case in range(1, int(input()) + 1):\n    N, M = map(int, input().split())\n    flies = []\n\n    for i in range(N):\n        flies.append(list(map(int, input().split())))\n\n    maxFlies = 0\n\n    for i in range(N):\n        for j in range(N):\n            killableFlies = getKillableFlies(i, j)\n            maxFlies = killableFlies if killableFlies > maxFlies else maxFlies\n\n    print(f'#{test_case} {maxFlies}')\n```\n",
    "tags": [
      "python",
      "구현"
    ],
    "date_started": "2024.07.04",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/algorithm/%ED%8C%8C%EB%A6%AC%ED%87%B4%EC%B9%98.md",
    "preview": ""
  },
  {
    "id": "posts/algorithm/숫자배열회전.md",
    "category": "Algorithm",
    "title": "숫자배열회전",
    "content": "\n## 1961\\_숫자배열회전 2024-07-04-19:12:21\n\n### [문제 링크]()\n\n### #구현\n\n| 입력 예     |\n| ----------- |\n| 2           |\n| 3           |\n| 1 2 3       |\n| 4 5 6       |\n| 7 8 9       |\n| 6           |\n| 6 9 4 7 0 5 |\n| 8 9 9 2 6 5 |\n| 6 8 5 4 9 8 |\n| 2 2 7 7 8 4 |\n| 7 5 1 9 7 9 |\n| 8 9 3 9 7 6 |\n\n| 출력 예              |\n| -------------------- |\n| #1                   |\n| 741 987 369          |\n| 852 654 258          |\n| 963 321 147          |\n| #2                   |\n| 872686 679398 558496 |\n| 952899 979157 069877 |\n| 317594 487722 724799 |\n| 997427 894586 495713 |\n| 778960 562998 998259 |\n| 694855 507496 686278 |\n\n---\n\n### Code\n\n<!-- CODE-APPENDED:1961_숫자배열회전.py -->\n```python\n\"\"\"\n\n\t1961_숫자배열회전 created at 2024-07-04-19:12:21\n\n\"\"\"\n\nimport sys\nsys.stdin = open(\"input.txt\", \"r\")\n\nfor test_case in range(1, int(input()) + 1):\n    N = int(input())\n    initialArray = [list(map(int, input().split())) for _ in range(N)]\n    rotations = []\n\n    # 90 x0들이 y0, x1들이 y1, ...\n    rotation = []\n    for i in range(N):\n        newLine = []\n        for j in range(N):\n            newLine.append(initialArray[N-1-j][i])\n        rotation.append(newLine)\n    rotations.append(rotation)\n    \n    # 180 중앙 대칭\n    rotation = []\n    for i in range(N):\n        newLine = []\n        for j in range(N):\n            newLine.append(initialArray[N-1-i][N-1-j])\n        rotation.append(newLine)\n    rotations.append(rotation)\n\n    # 270\n    rotation = []\n    for i in range(N):\n        newLine = []\n        for j in range(N):\n            newLine.append(initialArray[j][N-1-i])\n        rotation.append(newLine)\n    rotations.append(rotation)\n    \n    print(f'#{test_case}')\n    for i in range(N):\n        for arr in rotations:\n            print(*arr[i], end=\" \", sep='')\n        print()\n```\n",
    "tags": [
      "python",
      "구현"
    ],
    "date_started": "2024.07.04",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/algorithm/%EC%88%AB%EC%9E%90%EB%B0%B0%EC%97%B4%ED%9A%8C%EC%A0%84.md",
    "preview": ""
  },
  {
    "id": "posts/algorithm/최대_상금.md",
    "category": "Algorithm",
    "title": "최대 상금",
    "content": "\n## 1244\\_최대상금 2024-05-09-20:22:56\n\n### [문제 링크](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV15Khn6AN0CFAYD)\n\n### #DFS\n\n### 문제 요약\n\n최대 6자리 수 중 두개의 자리를 최대 10번 교환하여 만들 수 있는 가장 큰 수를 구하시오.\n\n| 입력 예          | 출력 예      |\n| ---------------- | ------------ |\n| `수` `교환 횟수` | `가장 큰 수` |\n| 123 1            | 321          |\n| 32886 3          | 88632        |\n\n### 첫인상\n\n이전에 비슷한 문제를 푼 기억이 있으나, 풀이가 기억나지는 않는다.\n\n6개의 수 중에 교환할 두 수를 중복하여 최대 10번을 고르는 경우의 수는 $15^{10}$개 이므로 시간 내에 불가능할 것이다.\n\n### 실패\n\n규칙을 찾아 직접 구현할 수 있을 것 같았다. 하지만 예시를 만들어보다가, 동일한 최고 숫자가 여러개 있을 경우 구현하기에 점점 복잡해지는 것을 발견했다.\n\n### 풀이\n\n[DFS 백트래킹]\n\n집에 걸어오면서 적은 경우의 수를 탐색하는 방법을 고민했고, 중복된 조합을 제거하면 최대 6자리이므로 10^6개의 경우의 수만 나올 것임을 깨달았다.\n\n*dfs*하며 각 depth(교환 횟수)마다 따로 중복 검사를 하여 통과했다. python의 set를 활용해 중복 검사를 상수 시간에 해결했다.\n\n### 시간 복잡도\n\n$최대 자릿수: l, 교환 횟수:k$\n\n$l$자리 수에서 나올 수 있는 조합은 최대 $10^l$개 (십진수이므로)  \n$l$개에서 2개를 $k$번 선택하는 경우의 수 $(l*(l-1)/2)^k$\n\n$∴ O(min(10^l, {l^2}^k))$\n\n### 회고\n\n대표적인 조합 문제인 것 같다. 푼지 너무 오래 되어서 바로 생각이 나지 않았다.  \n오래 기억하도록 정리하는 습관 들이기.  \n문제 꾸준히 풀기.\n\n---\n\n### Code\n\n<!-- CODE-APPENDED:1244_최대상금.py -->\n```python\n\"\"\"\n\n\t1244_최대 상금 2024-05-09 17:34:00\n\n\"\"\"\n\nimport sys\nsys.stdin = open(\"input.txt\", \"r\")\n\nglobal combinations\ndef dfs(price, chance):\n    if(price in combinations[chance]):\n        return\n    combinations[chance].add(price)\n    if(chance == 0):\n        return\n    for i in range(len(price)):\n        for j in range(i+1, len(price)):\n            list_price = list(price)\n            tmp = list_price[i]\n            list_price[i] = list_price[j]\n            list_price[j] = tmp\n            dfs(\"\".join(list_price), chance-1)\n\nT = int(input())\nfor test_case in range(1, T + 1):\n    price, chance = input().split()\n    chance = int(chance)\n\n    combinations = [set() for _ in range(chance+1)]\n    \n    dfs(price, chance)\n    print('#'+str(test_case), end=' ')\n    print(max(combinations[0]))\n```\n",
    "tags": [
      "DFS",
      "python"
    ],
    "date_started": "2024.06.16",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/algorithm/%EC%B5%9C%EB%8C%80_%EC%83%81%EA%B8%88.md",
    "preview": ""
  },
  {
    "id": "posts/algorithm/등산로_조성.md",
    "category": "Algorithm",
    "title": "등산로 조성",
    "content": "\n## 1949\\_등산로조성 2024-05-18-16:37:31\n\n### [문제 링크](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5PoOKKAPIDFAUq)\n\n### #DFS #완전탐색\n\n### 문제 요약\n\n땅의 높이가 2차원 배열로 주어진다. 여기에 등산로를 만들기 위해, 가장 높은 곳부터, 주변 낮은 땅으로만 길을 만든다고 하자. 한 좌표의 높이를 최대 K만큼 깎는 공사를 할 수 있다. 이 때 만들 수 있는 가장 긴 등산로를 구하시오\n\n| 입력 예   |\n| --------- |\n| 11        |\n| 5 1       |\n| 9 3 2 3 2 |\n| 6 3 1 7 5 |\n| 3 4 8 9 9 |\n| 2 3 7 7 7 |\n| 7 6 5 5 8 |\n\n| 출력 예 |\n| ------- |\n| 1 6     |\n\n### 풀이\n\nmap 크기 N과 최대 공사 깊이 K가 작아 완전탐색했다.<br>\nvisited 변수를 set로 만들기 위해 좌표를 문자열로 보관했다. [1,1] -> \"11\"<br>\n문제 해석 과정에서, 출발 위치의 좌표가 산을 깎기 전, 가장 높은 곳으로 선정된다는 것을 모르고,<br>\n산을 깎고 나서 가장 높은 곳부터 출발할 수 있다고 오인해 51개 test 중 계속 50개만 맞았다.\n\n$∴ O(K*N^4)$\n\n---\n\n### Code\n\n<!-- CODE-APPENDED:1949_등산로조성.py -->\n```python\n\"\"\"\n\n\t1949_등산로조성 created at 2024-05-18-16:37:31\n\n    완전탐색 구현: 깎을위치(N(<=8)**2) * 깎을높이K(<=5)~0 * 출발지(N**2) * DFS(N*N) = 5 * 64 * 64 * 64 = 최대 대략 64만회\n\n\"\"\"\n\nimport sys\nsys.stdin = open(\"input.txt\", \"r\")\n\ndirections = [[0,1], [1,0], [-1,0], [0, -1]]\n\nglobal geo_map, N\n\ndef DFS(y, x, visited):\n    string_coord = str(y)+str(x)\n    if string_coord in visited:\n        return 0\n    visited.add(string_coord)\n    res = 1\n    for dy, dx in directions:\n        ny = y + dy\n        nx = x + dx\n        if (0<=ny<N) and (0<=nx<N) and (geo_map[ny][nx]<geo_map[y][x]):\n            res = max(res, 1+DFS(ny, nx, visited))\n    visited.remove(string_coord)\n    return res\n    \n\nfor test_case in range(1, int(input()) + 1):\n    N, K = map(int, input().split())\n\n    geo_map = [list(map(int, input().split())) for _ in range(N)]\n\n    max_height = 0\n    for y in range(N):\n        for x in range(N):\n            if geo_map[y][x] > max_height:\n                max_height = geo_map[y][x]\n\n    starting_points = []\n    for y in range(N):\n        for x in range(N):\n            if geo_map[y][x] == max_height:\n                starting_points.append([y,x])\n    max_length = 0\n    for cutting_y in range(N):\n        for cutting_x in range(N):\n            for cutting_depth in range(K+1):\n                geo_map[cutting_y][cutting_x] -= cutting_depth\n\n\n                for y, x in starting_points:\n                        length = DFS(y, x, set())\n                        if length>max_length:\n                            max_length = length\n                    \n                geo_map[cutting_y][cutting_x] += cutting_depth\n\n    print(f'#{test_case} {max_length}')\n```\n",
    "tags": [
      "DFS",
      "python"
    ],
    "date_started": "2024.06.16",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/algorithm/%EB%93%B1%EC%82%B0%EB%A1%9C_%EC%A1%B0%EC%84%B1.md",
    "preview": ""
  },
  {
    "id": "posts/study/web.md",
    "category": "Study",
    "title": "Web",
    "content": "\n<img src= 'https://github.com/user-attachments/assets/4621b2f2-f1e1-4b47-b0c8-9e355ea46f37'\nalt='naver' />\n\n# WEB Client 기본 동작\n\n네이버에 접속하려 한다. 그래서 주소창에 _www.naver.com_을 입력하고 엔터를 친다. 여느 때와 다름 없이 네이버 페이지가 로딩된다. 이미지가 보여지고, HTML에 CSS가 입혀진 모습이다. 버튼들이 각자의 역할을 수행하고 있다. 무슨 일이 일어난 것일까?\n\n## 클라이언트와 서버\n\n페이지를 내 브라우저에 띄울려면, 해당 페이지의 정보를 가지고 있어야 한다. 세상 모든 페이지의 정보를 내 컴퓨터에 안전하게 저장하는 것은 불가능할 것이다. 따라서 우리는, 고객이 페이지 정보를 요청할 때마다 주인장이 고객에게 페이지 정보를 전송하는 방법을 쓴다.<br>\n여기서 당연히 고객이 `Client`, 주인장이 `Server`가 된다.<br>\n`Browser`는 `Client`측에서 사용하는 Chrome, Edge와 같이 웹 엔진이 담긴 프로그램을 의미한다.\n\n> Client: 어이 네이버! 맥주 한 잔 주쇼!<br>\n> Server: 예. 여기 HTML과 CSS와 JS입니다.\n\n## DNS(Domain Name System)\n\n컴퓨터는 다른 컴퓨터에 무언가를 보내기 위해 IP를 알아야 한다. 따라서 _www.naver.com_에 무언가 보내라고 하면 못 알아듣는다. 그래서 이걸 들고 DNS에 가서 해당하는 IP를 물어본다.<br>\n위처럼 단순한 과정이 아니었던 것이다.\n\n> Client: 여기 주인장 이름이 뭐요?<br>\n> DNS: 192.168.0.68 입니다.<br>\n> CLient: 어이 192.168.0.68! 맥주 한 잔 주쇼!<br>\n> Server(192.168.0.68): 예. 여기 HTML과 CSS와 JS입니다.\n\n## TCP/IP\n\n## Browser 페이지 파싱 순서\n\n-   브라우저는 먼저 HTML을 읽어들인다. 그러면서 CSS stylesheets를 참조하는 `<link>` 엘리먼트와 스크립트들을 참조하는 `<script>`-엘리먼트를 발견하게 된다.\n-   브라우저는 HTML을 읽어들이면서, 찾은 `<link>`나 `<script>` 태그에 대하여 서버에 다시 reqeust를 보낸다. 그리고 그 응답으로부터 CSS와 JavaScript를 읽어들인다.\n-   브라우저는 읽어들인 HTML으로 in-memory [DOM(Document Object Model)](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model) tree를, CSS로부터 in-memory CSSOM을 생성한다. 그리고 JavaScript를 컴파일하고 실행한다.\n\n이렇게 브라우저가 DOM tree와 CSSOM tree를 생성하고 JavaScript를 실행하면서, 페이지 정보가 창에 띄워지고, 사용자가 상호작용할 수 있게 된다.\n\n\n---\n\n### 참고 자료\n\n- [How the web works - MDN](https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web/How_the_Web_works)\n\n",
    "tags": [
      "theory"
    ],
    "date_started": "2024.06.14",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/study/web.md",
    "preview": ""
  },
  {
    "id": "posts/study/ssr_csr.md",
    "category": "Study",
    "title": "SSR",
    "content": "\n# SSR (vs CSR)\n\n## Sever side rendering은 서버에서 만들어둔 html을 client에게 응답으로 돌려주는 것을 말한다.\n\n## Client side rendering은 client 측에서 서버로부터 받아온 js를 이용해서 html을 조합해 보여주는 것을 말한다.\n\n예시로 React 프로젝트를 보면, public에 index.html이 껍데기만 있는 것을 볼 수 있다.<br>\n내용은 브라우저가 스크립트를 실행하면서 채우게 된다.\n\n## 각각의 장단점은 아래와 같다.\n\n### SSR\n\n- SSR은 html이 통으로 서버에 올라가기 때문에, 검색 엔진에게 분석당하기 좋다. 따라서 SEO가 좋다고 한다.\n- 또한, 서버에서 통으로 보내주기 때문에 브라우저의 부하를 덜어준다. > 최초 로딩 속도도 빠르다.\n\n### CSR\n\n- CSR은 SPA 구현이 가능해진다. 즉, 라우팅할 때마다 서버에서 매번 페이지를 불러오는 것이 아니라, 처음에 불러왔던 스크립트를 이용해 화면을 띄우는 것이 가능하다.\n- 이로써 라우팅 속도가 매우 빨라진다.\n- 부분 랜더링과 같은 동적 페이지 구현이 가능해진다.\n\n> 내가 오해했던 것이 이 두 방법은 상호 배타적인 개념이 아니라는 것이다. 따라서 섞어서 사용할 수 있다.<br>\n> 예를 들어, index.html이라는 페이지에 어느 정도 데이터만 넣어놓고,<br>\n> 유즈 케이스에 따라 스크립트를 이용해서 돔 요소를 변경하는 페이지를 만들 수도 있을 것이다.\n",
    "tags": [
      "theory"
    ],
    "date_started": "2024.06.14",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/study/ssr_csr.md",
    "preview": ""
  },
  {
    "id": "posts/study/react.md",
    "category": "Study",
    "title": "React",
    "content": "\n<img src= 'https://github.com/user-attachments/assets/4b3064ae-da83-42a2-968e-8c47915f9571'\nalt='react' />\n\n> 리액트 개념 정리\n\n# Hook\n\nHooks are special functions that are only available while React is rendering (which we'll get into in more detail on the next page). They let you \"hook into\" different React features.\n\nState는 컴포넌트가 기억할 정보를 담는다. [(왜 그냥 js 변수를 쓰지 않는가?)](https://react.dev/learn/state-a-components-memory#when-a-regular-variable-isnt-enough)\n\n## State Hooks\n\n### [`useState`](https://react.dev/reference/react/useState)\n\n컴포넌트가 기억할 정보와 이를 업데이트할 수 있는 함수를 제공한다.<br>\n[`useState`는 매 랜더링마다 어떻게 state를 구분하는가? (id를 적는 것도 아닌데?)](https://react.dev/learn/state-a-components-memory#how-does-react-know-which-state-to-return)\n\n### [`useReducer`](https://react.dev/reference/react/useReducer)\n\nState를 변경하는 방식을 지정한다. Class에서 set property를 지정하는 것과 비슷하다.\n\n[whosleejunghyeok](https://wndgur2.github.io/) 프로젝트의 data fetching에 이를 적용했다.\n\n한 포스트를 불러올 때마다 `posts` State를 업데이트해주고자 했는데, 이를 날짜순으로 정렬하기 원했다.<br>\n기존에는 이를 아래와 같은 코드로 구현했다.\n\n```jsx\nsetPosts((prevPosts: _Post[]): _Post[] => {\n    if (prevPosts.find((prevPost: _Post) => prevPost.id === post.id))\n        return prevPosts;\n    return [...prevPosts, post].sort((a: _Post, b: _Post) => {\n        if (a.date_started > b.date_started) return -1;\n        if (a.date_started < b.date_started) return 1;\n        return 0;\n    });\n});\n```\n\n위 코드는 정렬 자체도 비효율적일 뿐더러(이미 정렬되어있는 것이 활용되지 않음) 같은 코드가 `fetchPosts`와 `fetchProjects`에 중복 작성되어있었다.\n\n위 코드는 아래처럼 단순해졌다.\n\n```jsx\ndispatch({ type: \"INSERT_POST\", payload: post });\n```\n\n`INSERT_POST`라는 action을 `postsReducer.ts`의 `reducer`에 정의했다.\n\n```typescript\nconst reducer = (state: _Post[], action: PostAction): _Post[] => {\n    switch (action.type) {\n        case \"INSERT_POST\":\n            // if post already exists, return state\n            if (\n                state.find(\n                    (prevPost: _Post) => prevPost.id === action.payload.id\n                )\n            )\n                return state;\n\n            let index;\n            while (left <= right) {\n                index = Math.floor((left + right) / 2);\n                if (state[index].date_started === action.payload.date_started)\n                    break;\n                if (state[index].date_started < action.payload.date_started)\n                    right = index - 1;\n                else left = index + 1;\n            }\n            return [\n                ...state.slice(0, index),\n                action.payload,\n                ...state.slice(index),\n            ];\n\n        default:\n            return state;\n    }\n};\n```\n\n`ACTION`을 정의해 중복 코드를 방지하고 한김에 정렬 로직도 이진 탐색을 이용했다.<br>\n코드 구분이 명확해졌고 확장성도 좋아졌다! posts를 마음껏 다뤄도 체계적으로 짤 수 있겠다는 상상이 든다.\n\n<br>\n\n## Ref Hooks\n\nRefs let a component hold some information that isn't used for rendering, like a DOM node or a timeout ID. Unlike with state, updating a ref does not re-render your component. Refs are an \"escape hatch\" from the React paradigm. They are useful when you need to work with non-React systems, such as the built-in browser APIs.\n\n### [`useRef`](https://react.dev/reference/react/useRef)\n\ndeclares a ref. You can hold any value in it, but most often it's used to hold a DOM node.\n\n## Effect Hooks\n\n### `useEffect`\n\n## Performance Hooks\n\n### [`useMemo`](https://react.dev/reference/react/useMemo)\n\n`useMemo` vs `useEffect`&&`useState`\n\n1. Purpose<br>\n   `useEffect`: Manages side effects such as data fetching, subscriptions, or manual DOM manipulations.<br>\n   `useMemo`: Memoizes a value so that it is recalculated only when its dependencies change. Used to optimize performance by avoiding expensive calculations on every render.\n2. Usage<br>\n   `useEffect`: Runs a function after the component renders. Can run on every render or conditionally based on dependencies.<br>\n   `useMemo`: is purely for performance optimization. It doesn't manage state or side effects but caches a computed value.\n3. Performance<br>\n   흉내낼 순 있지만, 목적이 다르기 때문에, 값이 바뀌는 타이밍과 개선되는 성능이 다르다. 또 코드의 명확성을 따지면 useMemo만 쓰는 것이 당연히 좋다.\n\n### [`useCallback`](https://react.dev/reference/react/useCallback)\n\nIn JavaScript, **a function () {} or () => {} always creates a different function**, similar to how the {} object literal always creates a new object. Normally, this wouldn't be a problem, but it means that ShippingForm props will never be the same, and your memo optimization won't work. This is where useCallback comes in handy.<br>\n리랜더링 시 같은 함수를 계속 생성하는 것을 방지한다.\n\n### Custom Hook\n\nCustom hook과 javascript function의 차이는 뭘까?\n\n### Component\n\nReact lets you create components, reusable UI elements for your app.\n\nIn a React app, every piece of UI is a component.\n\nReact components are regular JavaScript functions except:\n\nTheir names always begin with a capital letter.\nThey return JSX markup.\n\n### Context\n\n전역 State 관리\n\n### Redux\n\n전역 State 관리 + a\n상태 관리 툴 for browser. (vs Mobx(object-oriented))\n\n---\n\n### 참고\n- [React.dev](https://react.dev/)\n",
    "tags": [
      "react",
      "spa"
    ],
    "date_started": "2024.06.14",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/study/react.md",
    "preview": ""
  },
  {
    "id": "posts/algorithm/삼성시의_버스_노선.md",
    "category": "Algorithm",
    "title": "삼성시의 버스 노선",
    "content": "\n## 6485\\_삼성시의버스노선 2024-05-19-03:42:50\n\n### [문제 링크](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWczm7QaACgDFAWn)\n\n### #구현 #스택\n\n### 문제 요약\n\n버스 노선 정보가 P개 주어진다. ex) 1~5 정류장까지 운행한다. 각 정류장들에 지나는 노선의 개수를 출력하라.\n\n| 입력 예 |\n| ------- |\n| 1       |\n| 2       |\n| 1 3     |\n| 2 5     |\n| 5       |\n| 1       |\n| 2       |\n| 3       |\n| 4       |\n| 5       |\n\n| 출력 예      |\n| ------------ |\n| #1 1 2 2 1 1 |\n\n### 풀이\n\n시간 복잡도를 대강 계산해도 널널해서 모든 정류장의 노선 개수를 리스트에 저장하도록 구현했다.<br>\n정류장의 번호 최대값인 5000번 정류장까지 담기 위해 5000개를 담는 리스트를 사용했다.<br>\n노선 정보가 들어올 때마다 배열을 도는 것은 비효율적이므로 스택 구조를 이용해 정류장의 시작 지점과 끝 지점만 저장해 놓고,<br>\n실제 노선 개수를 담는 수행은 5000개 인덱스를 한 번 돌게끔 했다.<br>\n약 15분 소요했다.\n\n---\n\n### Code\n\n<!-- CODE-APPENDED:6485_삼성시의버스노선.py -->\n```python\n'''\n    500개 정류장이 0과 5000번사이에 분포\n\n    범위 체크만 해놓고\n    스택구조로 마지막에 +하고 -하면서 정리\n    5000회 하고 500회\n\n'''\nimport sys\nsys.stdin = open(\"input.txt\", \"r\")\n\nfor tc in range(1, int(input())+1):\n    lane_n = int(input())\n\n    laneStartEnd = [0] * 5000\n    for i in range(lane_n):\n        A, B = map(int, input().split())\n        laneStartEnd[A-1] += 1\n        if B < 5000:\n            laneStartEnd[B] -= 1\n\n    # print(*laneStartEnd)\n\n    laneAmounts = [0]*5000\n    cur_lanes = 0\n    for i in range(5000):\n        cur_lanes += laneStartEnd[i]\n        laneAmounts[i] += cur_lanes\n    \n    stop_n = int(input())\n\n    to_print = []\n    for i in range(stop_n):\n        to_print.append(int(input()))\n    \n    result = \"\"\n    for i in to_print:\n        result += str(laneAmounts[i-1]) + \" \"\n    print(f'#{tc} {result[:-1]}')\n```\n",
    "tags": [
      "python",
      "스택"
    ],
    "date_started": "2024.05.19",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/algorithm/%EC%82%BC%EC%84%B1%EC%8B%9C%EC%9D%98_%EB%B2%84%EC%8A%A4_%EB%85%B8%EC%84%A0.md",
    "preview": ""
  },
  {
    "id": "posts/algorithm/공평한_분배2.md",
    "category": "Algorithm",
    "title": "공평한 분배2",
    "content": "\n## 20728\\_공평한분배2 2024-05-19-00:46:40\n\n### [문제 링크](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AY6cg0MKeVkDFAXt)\n\n### #정렬\n\n### 문제 요약\n\n총 사탕 주머니의 개수와, 뽑는 사탕 주머니 개수 K이 주어진다. 이후 각 사탕 주머니에 들어있는 사탕 수가 주어진다. K개의 사탕 주머니를 뽑아, 사탕이 가장 많이 들어있는 주머니와 가장 적게 들어있는 주머니의 개수 차이가 최소가 되도록 뽑으면, 그 차이가 몇 개인지 구하라.\n\n| 입력 예   |\n| --------- |\n| 4         |\n| 3 2       |\n| 1 2 3     |\n| 3 3       |\n| 5 20 10   |\n| 4 3       |\n| 4 3 2 1   |\n| 5 3       |\n| 1 2 3 4 5 |\n\n| 출력 예 |\n| ------- |\n| #1 1    |\n| #2 15   |\n| #3 2    |\n\n### 풀이\n\n사탕 개수 순으로 주머니를 정렬한 후, K 간격에 있는 주머니들의 차이의 최솟값을 구했다.\n\n뽑는 사탕 주머니 개수 $K$  \n총 사탕 주머니의 개수 $N$  \n$∴ O(N - K)$\n\n---\n\n### Code\n\n<!-- CODE-APPENDED:20728_공평한분배.py -->\n```python\n\"\"\"\n\n\t20728_공평한분배 created at 2024-05-19-00:46:40\n\n\"\"\"\n\nimport sys\nsys.stdin = open(\"input.txt\", \"r\")\n\nfor test_case in range(1, int(input()) + 1):\n    N, M = map(int, input().split())\n    candies = list(map(int, input().split()))\n    candies.sort()\n    dif = 2e9\n    for i in range(0, len(candies)-M+1):\n        cur_dif = candies[i+M-1] - candies[i]\n        if cur_dif < dif:\n            dif = cur_dif\n    print(f'#{test_case} {int(dif)}')\n```\n",
    "tags": [
      "python",
      "정렬"
    ],
    "date_started": "2024.05.19",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/algorithm/%EA%B3%B5%ED%8F%89%ED%95%9C_%EB%B6%84%EB%B0%B02.md",
    "preview": ""
  },
  {
    "id": "posts/algorithm/암호코드_스캔.md",
    "category": "Algorithm",
    "title": "암호코드 스캔",
    "content": "\n## 1242\\_암호코드스캔 2024-05-17-15:00:07\n\n### [문제 링크](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV15JEKKAM8CFAYD)\n\n### #구현 #문자열 #해시\n\n### 문제 요약\n\n문제가 매우 기므로 링크를 참조하시길 바랍니다. (복제는 금지되어있습니다.)\n\n| 입력 예                                            |\n| -------------------------------------------------- |\n| 2                                                  |\n| 16 26                                              |\n| 00000000000000000000000000                         |\n| 00000000000000000000000000                         |\n| 000000001DB176C588D26EC000                         |\n| 000000001DB176C588D26EC000                         |\n| 000000001DB176C588D26EC000                         |\n| 000000001DB176C588D26EC000                         |\n| 000000001DB176C588D26EC000                         |\n| 000000001DB176C588D26EC000                         |\n| 000000001DB176C588D26EC000                         |\n| 000000001DB176C588D26EC000                         |\n| 000000001DB176C588D26EC000                         |\n| 000000001DB176C588D26EC000                         |\n| 000000001DB176C588D26EC000                         |\n| 000000001DB176C588D26EC000                         |\n| 00000000000000000000000000                         |\n| 00000000000000000000000000                         |\n| 18 50                                              |\n| 00000000000000000000000000000000000000000000000000 |\n| 00000000000000000000000000000000000000000000000000 |\n| 000000000000000000000000000196EBC5A316C57800000000 |\n| 000000000000000000000000000196EBC5A316C57800000000 |\n| 000000328D1AF6E4C9BB0000000196EBC5A316C57800000000 |\n| 000000328D1AF6E4C9BB0000000196EBC5A316C57800000000 |\n| 000000328D1AF6E4C9BB0000000196EBC5A316C57800000000 |\n| 000000328D1AF6E4C9BB0000000196EBC5A316C57800000000 |\n| 000000328D1AF6E4C9BB0000000196EBC5A316C57800000000 |\n| 000000328D1AF6E4C9BB0000000196EBC5A316C57800000000 |\n| 000000328D1AF6E4C9BB0000000196EBC5A316C57800000000 |\n| 000000328D1AF6E4C9BB0000000196EBC5A316C57800000000 |\n| 000000328D1AF6E4C9BB0000000196EBC5A316C57800000000 |\n| 000000328D1AF6E4C9BB0000000196EBC5A316C57800000000 |\n| 000000000000000000000000000196EBC5A316C57800000000 |\n| 000000000000000000000000000196EBC5A316C57800000000 |\n| 00000000000000000000000000000000000000000000000000 |\n| 00000000000000000000000000000000000000000000000000 |\n\n| 출력 예 |\n| ------- |\n| #1 38   |\n| #2 48   |\n\n### 풀이\n\n문자열 처리와 해싱을 통한 구현 문제이다. 시간이 상당히 오래걸렸다.  \n원인은 아래 문제였던 것 같다.\n\n-   이런 문제 난이도일 것이라고 생각을 못했다.\n-   복잡한 구현을 오랜만에 해서, 최적화할 방법(쉽게 코드로 바꿀 방법)을 잘 떠올리지 못했다.\n\n이진수로 쉽게 변환하는 방법을 배웠다.\n\n```python\n    binary = \"{:04b}\".format(int(hexChar, 16))\n```\n\n시간 복잡도는 들어오는 입력 크기에 비례한다.  \n$∴ O(H * W)$ ($H$ = 입력 줄 개수, $W$ = 입력 줄 길이)\n\n최악의 경우에는 이렇지만, 입력줄을 set으로 받아 중복을 제거했기에 웬만하면 훨씬 빨리 수행할 것이다.\n\n---\n\n### Code\n\n<!-- CODE-APPENDED:1242_암호코드스캔.py -->\n```python\n\"\"\"\n\n\t1242_암호코드스캔 created at 2024-05-17 15:00:07\n\n\"\"\"\n\nimport sys\nsys.stdin = open(\"input.txt\", \"r\")\n\ndecode_map = {\"211\": 0, \"221\": 1,\"122\": 2,\"411\": 3,\"132\": 4,\"231\": 5,\"114\": 6,\"312\": 7,\"213\": 8,\"112\": 9,}\nvisited_code = set()\n\ndef decode(arr):\n    # arr[0], arr[1], arr[2]의 ratio 구하기 (1~4)\n    min_value = min(arr)\n    key = \"\"\n    for i in range(len(arr)):\n        if arr[i]%min_value != 0:\n            return -1\n        arr[i] = arr[i]/min_value\n        key += str(int(arr[i]))\n    if key not in decode_map:\n        return -1\n    return str(decode_map[key])\n    \ndef validateCode(code):\n    if code in visited_code:\n        return False\n    visited_code.add(code)\n    oddSum = 0\n    evenSum = 0\n    isOdd = True\n    for i in range(len(code)-1):\n        if isOdd:\n            oddSum += int(code[i])\n        else:\n            evenSum += int(code[i])\n        isOdd = not isOdd\n    auth = (10-(oddSum*3 + evenSum)%10)%10\n    return auth==int(code[-1])\n\nfor test_case in range(1, int(input()) + 1):\n    H, W = map(int, input().strip().split())\n    hexData = set()\n    for i in range(H):\n        hexData.add(input().strip())\n    \n    binaryData = []\n    for hexString in hexData:\n        binaryString = \"\"\n        for hexChar in hexString:\n            binaryString += \"{:04b}\".format(int(hexChar, 16))\n        binaryString = binaryString.rstrip(\"0\")\n        if binaryString:\n            binaryString += '0'\n            binaryData.append(binaryString)\n    \n    code_suspects = []\n    for binaryString in binaryData:\n        code_suspect = \"\"\n        \n        before = '0'\n        amount = 0\n        amounts = []\n        for binaryChar in binaryString:\n            if binaryChar != before:\n                if before!='0' or len(amounts)!=0:\n                    amounts.append(amount)\n                amount = 0\n                before = binaryChar\n\n                if len(amounts) == 3:\n                    decode_result = decode(amounts)\n                    if decode_result == -1:\n                        code_suspect = \"\"\n                    else:\n                        code_suspect += decode_result\n                    if len(code_suspect) == 8:\n                        code_suspects.append(code_suspect)\n                        code_suspect = \"\"\n                    amounts = []\n                    before = '0' # 다음 암호 찾기 위함\n            amount += 1\n    result = 0\n    for code in code_suspects:\n        if validateCode(code):\n            result += sum(map(int, list(code)))\n    print(f'#{test_case} {result}')\n```\n",
    "tags": [
      "python",
      "구현",
      "해시"
    ],
    "date_started": "2024.05.17",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/algorithm/%EC%95%94%ED%98%B8%EC%BD%94%EB%93%9C_%EC%8A%A4%EC%BA%94.md",
    "preview": ""
  },
  {
    "id": "posts/algorithm/최적_경로.md",
    "category": "Algorithm",
    "title": "최적 경로",
    "content": "\n## 1247\\_최적경로 2024-05-16-13:50:09\n\n### [문제 링크](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV15OZ4qAPICFAYD)\n\n### #완전탐색 #DFS #순열\n\n### 문제 요약\n\n좌표 (0,0) ~ (100,100)에 회사와 집, 그리고 N명의 고객 좌표가 주어진다. 회사에서 집에 가는 길에, 모든 고객을 거쳐 오는 최단거리를 구하시오.\n\n| 입력 예                                                             |\n| ------------------------------------------------------------------- |\n| 3                                                                   |\n| 5                                                                   |\n| 0 0 100 100 70 40 30 10 10 5 90 70 50 20                            |\n| 6                                                                   |\n| 88 81 85 80 19 22 31 15 27 29 30 10 20 26 5 14                      |\n| 10                                                                  |\n| 39 9 97 61 35 93 62 64 96 39 36 36 9 59 59 96 61 7 64 43 43 58 1 36 |\n\n| 출력 예 |\n| ------- |\n| #1 200  |\n| #2 304  |\n| #3 366  |\n\n### 풀이\n\nN개의 고객을 방문하는 조합을 구하고, 그 거리에 집과 회사를 포함해 최단거리를 찾았다.  \n시간 복잡도는 N명의 고객을 방문하는 순열의 개수이다.  \n$∴ O(N!)$\n\n간단한 문제였는데 한 시간 이상 걸렸다. N개의 순열을 구하는데 bfs로 했더니 메모리 초과가 났다. dfs로 수정해서 해결했다.\n\n---\n\n### Code\n\n<!-- CODE-APPENDED:1247_최적경로.py -->\n```python\n\"\"\"\n\n\t1247_최적경로 created at 2024-05-16 13:50:09\n\n\"\"\"\n\nimport sys\nsys.stdin = open(\"input.txt\", \"r\")\n\nfor test_case in range(1, int(input()) + 1):\n    N = int(input())\n    xys = list(map(int, input().split()))\n    company = [xys[0], xys[1]]\n    home = [xys[2], xys[3]]\n    nodes = [home]\n    isX = True\n    for xy in xys[4:]:\n        if(isX):\n            nodes.append([xy])\n        else:\n            nodes[-1].append(xy)\n        isX = not isX\n    nodes.append(company)\n\n    # 완전 탐색\n    # n-1 순회하기\n    # [0, 2~n+1 조합, 1]\n    \n    min_cost = 2e9\n    branches = [[0]]\n    routes = []\n    while branches:\n        branch = branches.pop()\n        if len(branch) == N+1:\n            branch = branch + [N+1]\n            cost = 0\n            for i in range(N+1):\n                cost += abs(nodes[branch[i]][0] - nodes[branch[i+1]][0])\\\n                    + abs(nodes[branch[i]][1] - nodes[branch[i+1]][1])\n            if cost<min_cost:\n                min_cost = cost\n            continue\n        for i in range(N+1):\n            if i not in branch:\n                branches.append(branch + [i])\n\n\n    print(f'#{test_case} {min_cost}')\n```\n",
    "tags": [
      "DFS",
      "python",
      "순열"
    ],
    "date_started": "2024.05.16",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/algorithm/%EC%B5%9C%EC%A0%81_%EA%B2%BD%EB%A1%9C.md",
    "preview": ""
  },
  {
    "id": "posts/algorithm/공통_조상.md",
    "category": "Algorithm",
    "title": "공통 조상",
    "content": "\n## 1248\\_공통조상 2024-05-16-13:06:38\n\n### [문제 링크](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV15PTkqAPYCFAYD)\n\n### #트리\n\n### 문제 요약\n\n이진 트리가 주어진다. 주어진 두 정점의 가장 가까운 공통 조상을 구하고, 공통 조상을 루트로 하는 서브트리의 크기를 구하라.\n\n| 입력 예                                              |\n| ---------------------------------------------------- |\n| 10                                                   |\n| 13 12 8 13                                           |\n| 1 2 1 3 2 4 3 5 3 6 4 7 7 12 5 9 5 8 6 11 6 10 11 13 |\n\n| 출력 예 |\n| ------- |\n| #1 3 8  |\n| #2 1 10 |\n\n### 풀이\n\n트리를 dictionary를 이용해 구현했다. parent 노드는 하나, children은 여럿이므로 각각 다른 dictionary에서 관리했다.\n\na, b의 공통 조상은 a의 부모를 따라가며 a의 모든 조상을 구하고 이를 set에 보관했다.(set의 find 시간 복잡도 O(1)이므로)\n그다음 b의 조상을 따라가며 set에 있는지 확인했다.\n\n그렇게 찾은 공통 조상을 루트로 하는 서브트리 크기는, children dictionary를 따라가며 DFS 완전탐색했다.\n\n$∴ O(V)$ ($V$=amount of vertexes)\n\n---\n\n### Code\n\n<!-- CODE-APPENDED:1248_공통조상.py -->\n```python\n\"\"\"\n\n\t1248_공통조상 created at 2024-05-16 13:06:38\n\n\"\"\"\n\nimport sys\nsys.stdin = open(\"input.txt\", \"r\")\n\nfor test_case in range(1, int(input()) + 1):\n    V, E, a, b = map(int, input().split())\n\n    # 1~V 정점 트리 만들기\n    # 위상 정렬?\n    # 모든 노드는 parent 엣지가 최대 하나다.\n    # dictionary 형으로 구현해보기\n\n    parentOf = {} # key의 parent 노드는 value.\n    childrenOf = {} # key의 children은 value[].\n    \n    isParent = True\n    for node in map(int, input().split()):\n        if isParent:\n            parent = node\n        else:\n            parentOf[node] = parent\n            if parent in childrenOf:\n                childrenOf[parent].append(node)\n            else:\n                childrenOf[parent] = [node]\n        isParent = not isParent\n\n    # a, b 공통 조상 찾기\n    # a의 조상을 모두 찾아놓고\n    # b의 조상을 iterate하며 있는지 확인\n    # 최대 depth가 9999이므로 시간 내에 가능\n    a_parents = set()\n    cur_node = a\n    while cur_node:\n        a_parents.add(cur_node)\n        if cur_node in parentOf:\n            cur_node = parentOf[cur_node]\n        else:\n            cur_node = 0\n    \n    cur_node = b\n    while cur_node:\n        if cur_node in a_parents:\n            common_parent = cur_node\n            break\n        if cur_node in parentOf:\n            cur_node = parentOf[cur_node]\n        else:\n            cur_node = 0\n\n    size = 0\n    branches = [common_parent]\n    while branches:\n        size += 1\n        node = branches.pop()\n        if node in childrenOf:\n            for n in childrenOf[node]:\n                branches.append(n)\n\n    print(f'#{test_case} {common_parent} {size}')\n```\n",
    "tags": [
      "python",
      "트리"
    ],
    "date_started": "2024.05.16",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/algorithm/%EA%B3%B5%ED%86%B5_%EC%A1%B0%EC%83%81.md",
    "preview": ""
  },
  {
    "id": "posts/algorithm/수영장.md",
    "category": "Algorithm",
    "title": "수영장",
    "content": "\n## 1952\\_수영장 2024-05-13-16:22:49\n\n### [문제 링크](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5PpFQaAQMDFAUq)\n\n### #DP\n\n### 문제 요약\n\n테스트케이스 수가 주어진다.\n내년에 다니려는 수영장의 가격이 주어진다. 1일권, 1개월권, 3개월권, 1년권이 있다.  \n내년에 다니려는 계획이 월별 일수로 주어진다.\n내년에 수영장을 계획대로 다닐 수 있는 최소 가격을 출력하라.\n\n| 입력 예                            |\n| ---------------------------------- |\n| 7                                  |\n| 10 40 100 300                      |\n| 0 0 2 9 1 5 0 0 0 0 0 0            |\n| 10 100 50 300                      |\n| 0 0 0 0 0 0 0 0 6 2 7 8            |\n| 10 70 180 400                      |\n| 6 9 7 7 7 5 5 0 0 0 0 0            |\n| 10 70 200 550                      |\n| 0 0 0 0 8 9 6 9 6 9 8 6            |\n| 10 80 200 550                      |\n| 0 8 9 15 1 13 2 4 9 0 0 0          |\n| 10 130 360 1200                    |\n| 0 0 0 15 14 11 15 13 12 15 10 15   |\n| 10 180 520 1900                    |\n| 0 18 16 16 19 19 18 18 15 16 17 16 |\n\n| 출력 예 |\n| ------- |\n| #1 110  |\n| #2 100  |\n| #3 400  |\n| #4 530  |\n| #5 430  |\n| #6 1080 |\n| #7 1840 |\n\n### 풀이\n\n[DP]\ndp[i]에 i월까지 다닐 수 있는 최소 비용을 담는다.\n\n$∴ O(n)$ ( $n$=다닐 개월 수 )\n\n약 30분 소요했다.\n\n---\n\n### Code\n\n<!-- CODE-APPENDED:1952_수영장.py -->\n```python\n\"\"\"\n\n\t1952_수영장 created at 2024-05-13 16:22:49\n\n    풀이: DP\n\n\"\"\"\nimport sys\nsys.stdin = open(\"input.txt\", \"r\")\n\nfor test_case in range(1, int(input()) + 1):\n    day_cost, month_cost, three_month_cost, year_cost = map(int, input().split())\n    monthly_plan = [0]\n    monthly_plan.extend(list(map(int, input().split())))\n    \n    # dp[i]에 들어갈 값? i월 까지 다니는 최소 비용\n\n    dp = [1e9]*13\n    dp[0] = 0\n    for i in range(1, len(dp)):\n        # 1월, 2월\n        if monthly_plan[i]*day_cost > month_cost:\n            dp[i] = dp[i-1] + month_cost\n        else:\n            dp[i] = dp[i-1] + monthly_plan[i]*day_cost\n\n        if i>=3:\n            dp[i] = min(dp[i], dp[i-3] + three_month_cost)\n        if i==12:\n            dp[i] = min(dp[i], year_cost)\n    print(f'#{test_case} {dp[12]}')\n```\n",
    "tags": [
      "DP",
      "python"
    ],
    "date_started": "2024.05.13",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/algorithm/%EC%88%98%EC%98%81%EC%9E%A5.md",
    "preview": ""
  },
  {
    "id": "posts/algorithm/상자_정렬하기.md",
    "category": "Algorithm",
    "title": "상자 정렬하기",
    "content": "\n## 20936\\_상자정렬하기 2024-05-10-13:43:06\n\n### [문제 링크]()\n\n### #정렬\n\n### 문제 요약\n\n1부터 N까지 번호가 붙은 N(1<=N<=500)개의 상자가 N+1개의 칸에 임의의 순서로 나열되어 있다. 하나의 빈칸을 이용해 상자를 하나씩 이동하여 정렬하라.\n\n| 입력 예         |\n| --------------- |\n| 2               |\n| 3               |\n| 1 2 3           |\n| 8               |\n| 5 6 7 2 3 4 1 8 |\n\n| 출력 예   |\n| --------- |\n| 0         |\n|           |\n| 5         |\n| 3 2 1 4 5 |\n\n### 첫인상\n\n정렬 구현인 듯 하다. 규칙을 찾아보자.\n\n### 풀이\n\n해당 칸에 들어가야 할 상자를 찾아서 넣으면,  \n찾는 데에 N, 이걸 N번, N^2 <= 250000이므로 3초에 가능할 듯하다.\n\n맨 오른쪽 칸이 비었을 때에는, 앞에서부터 칸에 맞지 않는 상자를 찾으면 그걸 옮긴다. 그 외에는, 해당 칸에 들어가야 할 상자를 찾아 옮긴다.\n\n### 시간 복잡도\n\n이동시킬 칸을 $N$번 찾는다.  \n$∴ O(N^2)$\n\n### 회고\n\n변수의 의미가 미세하게 다를 때 변수명 짓는게 어렵다. 나중에 보면 이해하기 어려울 것 같으니, 문제 해결 후 조금 더 고민해서 지어보기.\n\n### 해결 이후 개선\n\n빈 칸이 맨 오른쪽이 아니라 맨 왼쪽에서 시작한다고 하면 코드가 한결 간결해진다.  \n다만, 로그를 출력할 때, 0 대신 마지막 index를 출력해야했다.\n\n---\n\n### Code\n\n<!-- CODE-APPENDED:20936_상자정렬하기.py -->\n```python\n\"\"\"\n\n\t20936_상자 정렬하기 created at 2024-05-10 13:41:49\n\n    500개 이하의 상자, 하나의 빈칸을 이용해 정렬하기\n\n    이동 횟수, 이동한 칸 번호 순서대로 출력. 최단은 아니고 가능한 방법 중 하나.\n\n    1)  해당 칸에 들어가야 할 상자를 찾아서 넣으면,\n        -   찾는 데 n, 이걸 n번, n^2 = 250000회 -> 3초에 가능할 듯하다.\n    \n    맨 오른쪽 칸이 비었을 때에는, 앞에서부터 칸에 맞지 않는 상자를 찾으면 그걸 옮긴다.\n    그 외에는, 해당 칸에 들어가야 할 상자를 찾아 옮긴다.\n\n\"\"\"\n\nimport sys\nsys.stdin = open(\"input.txt\", \"r\")\n\ndef getNotSortedIndex(li):\n    index = 0\n    for n in li:\n        if n!= index:\n            return index\n        index += 1\n    return -1\n\nT = int(input())\nfor test_case in range(1, T + 1):\n    n = int(input())\n    log = []\n    baskets = [0]\n    baskets.extend(list(map(int, input().split())))\n    indexNotSorted = getNotSortedIndex(baskets) # 앞에서부터 정렬되지 않은 인덱스 탐색.\n    while(indexNotSorted != -1): # 정렬되어있으면 -1 리턴\n        if baskets[0] == 0:\n            baskets[0] = baskets[indexNotSorted]\n            baskets[indexNotSorted] = 0\n            log.append(indexNotSorted if indexNotSorted!=0 else len(baskets))\n        else:\n            indexBlank = baskets.index(0)\n            indexToMove = baskets.index(indexBlank)\n            baskets[indexBlank] = baskets[indexToMove]\n            baskets[indexToMove] = 0\n            log.append(indexToMove  if indexToMove!=0 else len(baskets))\n        indexNotSorted = getNotSortedIndex(baskets)\n    print(len(log))\n    print(*log)\n```\n",
    "tags": [
      "python",
      "정렬"
    ],
    "date_started": "2024.05.10",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/algorithm/%EC%83%81%EC%9E%90_%EC%A0%95%EB%A0%AC%ED%95%98%EA%B8%B0.md",
    "preview": ""
  },
  {
    "id": "posts/algorithm/보급로.md",
    "category": "Algorithm",
    "title": "보급로",
    "content": "\n## 1249\\_보급로 2024-05-10-14:41:59\n\n### [문제 링크](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV15QRX6APsCFAYD)\n\n### #BFS\n\n### 문제 요약\n\n가중치가 있는 지도가 주어진다. 4방으로 1칸 씩 이동하여 0, 0에서 N-1, N-1까지 가는 최소 비용을 출력하라.\n\n| 입력 예  |\n| -------- |\n| 3        |\n| 4        |\n| 0100     |\n| 1110     |\n| 1011     |\n| 1010     |\n| 6        |\n| 011001   |\n| 010100   |\n| 010011   |\n| 101001   |\n| 010101   |\n| 111010   |\n| 8        |\n| 01333212 |\n| 03121302 |\n| 01220112 |\n| 02003220 |\n| 13323020 |\n| 13010121 |\n| 23120012 |\n| 02322220 |\n\n| 출력 예 |\n| ------- |\n| #1 2    |\n| #2 2    |\n| #3 8    |\n\n### 첫인상\n\n대표적인 가중치를 이용한 백트래킹 문제?\n\n### 실패\n\n재귀호출로 인한 메모리 초과, 탐색 방향으로 인한 시간 초과를 겪었다.\n\n### 풀이\n\n[반복문 메모이제이션 DFS]  \nDFS를 반복문으로 구현해 메모리 초과를 해결했다.  \n시간 초과 원인에 대해 고민하다 시간 복잡도를 줄이기보다는 디테일한 문제라고 판단해서, 효율을 최대한 높이려고 했다. 그러다 눈에 밟힌 것이\n\n```python\n# 증가하는 경우\nif y<size-1:\n    branches.append([y+1, x, cost+cost_map[y+1][x]])\nif x<size-1:\n    branches.append([y, x+1, cost+cost_map[y][x+1]])\n# 감소하는 경우\nif y>0:\n    branches.append([y-1, x, cost+cost_map[y-1][x]])\nif x>0:\n    branches.append([y, x-1, cost+cost_map[y][x-1]])\n```\n\nDFS의 가지를 뻗는 부분이다. 잘 보면, y와 x가 증가하는 경우를 추가하고, 감소하는 부분을 추가한다.  \n여기서 문제는 branches.pop()은 리스트의 마지막 원소를 가져온다는 것.\n\n```python\nwhile branches:\n    y, x, cost = branches.pop() # O(1)\n    if (cost < min_stacked_cost_map[y][x]) or (min_stacked_cost_map[y][x]==-1):\n        min_stacked_cost_map[y][x] = cost\n    else:\n        continue\n    if (min_stacked_cost_map[size-1][size-1]!=-1) and (cost > min_stacked_cost_map[size-1][size-1]):\n        continue\n    if (y==size-1) and (x==size-1):\n        continue\n    if y<size-1:\n        branches.append([y+1, x, cost+cost_map[y+1][x]])\n    if x<size-1:\n        branches.append([y, x+1, cost+cost_map[y][x+1]])\n    if y>0:\n        branches.append([y-1, x, cost+cost_map[y-1][x]])\n    if x>0:\n        branches.append([y, x-1, cost+cost_map[y][x-1]])\n```\n\n따라서 나는 마지막으로 추가된 x가 감소하는 방향을 먼저 탐색하고, y가 감소하는 방향, x가 증가하는 방향, y가 증가하는 방향 순서로 탐색하고 있었다.\n\n이 append문 순서를 바꿔 시간 초과 문제를 해결했다.\n\n[BFS] 2024-05-13 16:10\n\n친구와 시간복잡도 계산을 하다가 다른 사람들이 제출한 코드의 실행 시간이, 내가 제출한 시간보다 10배 이상 빠른 것을 보고, 풀이를 찾아보았다. 결론은 BFS가 DFS보다 빠르다는 것.\n\n우리가 결론낸 그 원인은 이렇다.\n\n-   문제에 탐색 방향성이 있다. ([0,0]->[n-1,n-1])\n-   비용 맵을 그래프로 봤을 때 그래프의 엣지가 주변 노드로 정해져있다. (4방향)\n-   따라서 가까운 노드를 먼저 탐색하는 것이 유리하다.\n\n### 시간 복잡도\n\n기본적으로는 각 칸에서 발생하는 가지가 4개이므로 $O(4^{n*n})$이다.  \n하지만 메모이제이션으로 비용이 최소가 되는 경로만 유지하기 때문에 그보다 현저히 낮아진다.\n\n### 회고\n\n생각지 못한 메모리 초과와 시간 초과를 맞아 한 시간을 겨우 안 넘겼다.  \nDFS나 BFS나 한 방식으로만 구현해왔던 게 조금 시간을 잡아먹었다. 재귀 호출의 단점도 몰랐다.  \n따라서 알고리즘만 안다면, 다양한 방식으로, 장단점을 따져 구현할 줄 알아야겠다.  \n(유연한 구현?)\n\n---\n\n### Code\n\n<!-- CODE-APPENDED:1249_보급로.py -->\n```python\n\"\"\"\n\n\t1249_보급로 created at 2024-05-10 14:41:59\n\n    대표적인 가중치를 이용한 백트래킹 문제?\n\n    recursion DFS 메모리 초과 -> while문 DFS\n\n    while문 DFS 시간 초과 -> x, y 탐색 방향 수정 (-, - => +, +)\n\n\"\"\"\n\nimport sys\nsys.stdin = open(\"input.txt\", \"r\")\n\ndirections = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n\nfor test_case in range(1, int(input()) + 1):\n    size = int(input())\n    cost_map = [list(map(int, list(input()))) for _ in range(size)]\n    dp = [[1e9]*size for _ in range(size)]\n    dp[0][0] = 0\n    branches = [[0, 0]]\n    while branches:\n        y, x = branches.pop() # O(1)\n\n        if dp[y][x] > dp[size-1][size-1]:\n            continue\n        \n        for dy, dx in directions:\n            ny, nx = y+dy, x+dx\n            if (0<=ny<size) and (0<=nx<size):\n                if (dp[ny][nx] > dp[y][x]+cost_map[ny][nx]):\n                    dp[ny][nx] = dp[y][x]+cost_map[ny][nx]\n                    branches.append([ny, nx])\n\n    print(f'#{test_case} {dp[size-1][size-1]}')\n\n\n```\n",
    "tags": [
      "BFS",
      "python"
    ],
    "date_started": "2024.05.10",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/algorithm/%EB%B3%B4%EA%B8%89%EB%A1%9C.md",
    "preview": ""
  },
  {
    "id": "posts/algorithm/View.md",
    "category": "Algorithm",
    "title": "View",
    "content": "\n## 1206_view 2024-05-10-11:42:36\n\n### [문제 링크](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV134DPqAA8CFAYh)\n\n### #구현\n\n### 문제 요약\n\n빌딩의 개수와 높이가 주어진다. 가로로 2칸 이상 다른 빌딩이 없을 때, 조망권이 확보되었다고 하자. 조망권이 확보된 세대 수를 구하시오.\n\n| 입력 예                           |\n| --------------------------------- |\n| 10                                |\n| 0 0 254 185 76 227 84 175 0 0     |\n| 10                                |\n| 0 0 251 199 176 27 184 75 0 0     |\n| 11                                |\n| 0 0 118 90 243 178 99 100 200 0 0 |\n\n| 출력 예 |\n| ------- |\n| #1 111  |\n| #2 60   |\n| #3 165  |\n\n### 첫인상\n\n구현으로 할 수 있을 것 같다.\n\n### 풀이\n\n단순 구현으로 앞에서부터 5개의 빌딩의 높이를 비교했다. 최고 높이와 두 번째 높이를 필요로 했으며, 가장 높은 빌딩이 비교한 5개의 빌딩 중 가운데일 경우 정답에 최고높이-2등높이를 더했다.\n\n### 시간 복잡도\n\n연산은 빌딩의 수와 비례한다.  \n$∴ O(N)$\n\n### 회고\n\n단순 구현이어서 빠르게 풀었다. 실수를 하지 않은 것은 다행이었다.\n\n---\n\n### Code\n\n<!-- CODE-APPENDED:1206_view.py -->\n```python\n\"\"\"\n\n\t1206_view 2024-05-10 11:42:36\n\n\"\"\"\n\nimport sys\nsys.stdin = open(\"input.txt\", \"r\")\n\nT = 10\nfor test_case in range(1, T + 1):\n    '''\n        이 부분에 여러분의 알고리즘 구현이 들어갑니다.\n    '''\n    n = int(input())\n    buildings = list(map(int, input().split()))\n    answer = 0\n\n    for i in range(n-4):\n        highest = 0\n        second = 0\n        for b in [buildings[i+j] for j in range(5)]:\n            if(b >= highest):\n                second = highest\n                highest = b\n            elif(b > second):\n                second = b\n        if highest == buildings[i+2]:\n            answer += highest - second\n    print('#'+str(test_case), end=' ')\n    print(answer)\n```\n",
    "tags": [
      "python",
      "구현"
    ],
    "date_started": "2024.05.10",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/algorithm/View.md",
    "preview": ""
  },
  {
    "id": "posts/algorithm/방울마술.md",
    "category": "Algorithm",
    "title": "방울마술",
    "content": "\n## 20934\\_방울마술 2024-05-09-15:23:41\n\n### [문제 링크](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AY9QTGqqcckDFAVF)\n\n### #구현\n\n### 문제 요약\n\n세 개의 컵과 하나의 공으로 야바위를 한다. 처음 공의 위치와 공이 이동한 횟수가 주어졌을 때, 공이 있을 확률이 가장 높은 컵을 출력하라. (여러개면 왼쪽)\n\n| 입력 예 | 출력 예 |\n| ------- | ------- |\n| .o. 1   | 0       |\n| o.. 1   | 1       |\n| ..o 0   | 2       |\n\n### 첫인상\n\n익숙한 유형은 아니어서 규칙을 찾아보려고 했다.\n\n### 풀이\n\n공이 1번 이동할 때 각 컵 안에 있을 확률\n\n    o.. => 0% 100% 0%\n    .o. => 50% 0% 50%\n    ..o => 0% 100% 0%\n\n공이 이동할 때,  \n가운데에서 이동하면 확률은 좌우로 반반씩 나뉜다.  \n좌우에서 이동하면 확률은 가운데로 모인다.  \n이 두 가지를 독립적으로 동시에 작동하도록 해서 해결했다.\n\n### 시간 복잡도\n\n연산 횟수는 공이 이동하는 횟수 $k$에 비례한다.  \n$∴ O(k)$\n\n### 회고\n\n난이도가 쉬워서 재밌는 문제였다. 응용하면 복잡해질 수 있을 것 같다.\n\n---\n\n### Code\n\n<!-- CODE-APPENDED:20934_방울마술.py -->\n```python\n\"\"\"\n\n\t20934_방울 마술 2024-05-09 15:23:41\n\n\"\"\"\nimport sys\nsys.stdin = open(\"input.txt\", \"r\")\n\nT = int(input())\nfor test_case in range(1, T + 1):\n    possibility=[0, 0, 0]\n    loc, K = input().split()\n    loc = loc.find('o')\n    possibility[loc] = 100\n    K = int(K)\n    for i in range(K):\n        mid = possibility[1]\n        side = possibility[0] + possibility[2]\n        possibility[1] = side\n        possibility[0] = mid/2\n        possibility[2] = mid/2\n    idx=0\n    maximum = max(possibility)\n    print(\"#\" + str(test_case), end=\" \")\n    for pos in possibility:\n        if(pos == maximum):\n            print(idx)\n            break\n        idx+=1\n```\n",
    "tags": [
      "python",
      "구현"
    ],
    "date_started": "2024.05.09",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/algorithm/%EB%B0%A9%EC%9A%B8%EB%A7%88%EC%88%A0.md",
    "preview": ""
  },
  {
    "id": "posts/algorithm/min_max.md",
    "category": "Algorithm",
    "title": "min max",
    "content": "\n## min(), max()\n\n---\n\n### Code\n\n<!-- CODE-APPENDED:4828_min_max.py -->\n```python\n\"\"\"\n\n\t4828_min_max created at 2024-07-07-11:32:24\n    소요시간 3분\n\n\"\"\"\n\nimport sys\nsys.stdin = open(\"input.txt\", \"r\")\n\nfor test_case in range(1, int(input()) + 1):\n    N = input()\n    nums = list(map(int, input().split()))\n\n    print(f'#{test_case} {max(nums) - min(nums)}')\n```\n",
    "tags": [
      "python"
    ],
    "date_started": 2024,
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/algorithm/min_max.md",
    "preview": ""
  },
  {
    "id": "posts/algorithm/마법사_상어와_블리자드.md",
    "category": "Algorithm",
    "title": "마법사 상어와 블리자드",
    "content": "\n## 백준*21611*마법사*상어와*블리자드 2024-07-07\n\n### 카테고리 : 구현\n\n## [문제 설명](https://www.acmicpc.net/problem/21611)\n\n마법사 상어가 블리자드라는 스킬을 써서 구슬을 파괴하고,  \n같은 번호 구슬이 4개 이상 연속으로 있으면 애니팡처럼 폭발하는 게임이다.\n\n아래와 같은 달팽이 껍질 모양 맵에 구슬 1, 2, 3 이 차있다. (i: 칸 번호)\n<img width=\"566\" alt=\"칸_번호\" src=\"https://github.com/wndgur2/whosleejunghyeok/assets/65120311/b568b056-c779-4598-82ba-c72ea64ca30d\">\n\n블리자드(방향, 거리)를 써서 일직선 상의 구슬을 파괴한다. (i: 구슬 번호) ~\n<img width=\"838\" alt=\"구슬_파괴\" src=\"https://github.com/wndgur2/whosleejunghyeok/assets/65120311/27daeb50-f63c-40e4-9895-d6e4a10da201\">\n\n구슬이 또르르 굴러와 빈자리를 채운다.\n연속된 구슬이 4개 이상이면 폭발한다.\n<img width=\"848\" alt=\"구슬_폭발\" src=\"https://github.com/wndgur2/whosleejunghyeok/assets/65120311/800b5382-591a-4366-8627-38c370ca22b5\">\n\n구슬이 다시 굴러 빈자리를 채운다.\n폭발하는 구슬이 없을 때까지 반복한다.\n\n각 연속된 구슬 그룹은 2개의 구슬(연속된 구슬의 개수, 그 그룹의 구슬 번호)로 변화한다.\n<img width=\"1463\" alt=\"구슬_변화\" src=\"https://github.com/wndgur2/whosleejunghyeok/assets/65120311/fdb0c48f-8b7e-4c23-a391-6576dd62e865\">\n\n위 과정을 M번 반복한다.\n\n1×(폭발한 1번 구슬의 개수) + 2×(폭발한 2번 구슬의 개수) + 3×(폭발한 3번 구슬의 개수) 출력\n\n## 블리자드를 맞는 구슬의 인덱스 구하는 법\n\n달팽이 껍질 모양의 테이블\n안쪽 칸에서 바깥쪽 칸으로 가기 위한 인덱스 차이는,\n껍질이 커질 수록 커진다.\n\n<img width=\"566\" alt=\"칸_번호\" src=\"https://github.com/wndgur2/whosleejunghyeok/assets/65120311/b568b056-c779-4598-82ba-c72ea64ca30d\">\n그 증가량은, 껍질이 코너를 돌 때 1씩 2번 증가한다.\n\n7 7 8 9 9 10 11 11 11 12 13 13 13 14 15 15 15 15 16 16 16 16 17 17 17 17 17\n\n새로운 인덱스 차이를 구했으면, 해당 껍데기의 길이동안 유지된다. (꺾기 전까지 유지된다.)\n\n껍데기의 길이는 (북, 서), (남, 동)이 동일하다.\n\n↑방향으로 사거리 3인 블리자드는  \n7 22 45번 구슬을 파괴한다.  \n인덱스 증가값은 0에서부터 시작하므로 7, 15, 23이다.\n\n7: 초기값  \n15: 7 + 2 + 2 + 2 + 2 : 코너를 4번 돌아야 한다.  \n23: 15 + 2 + 2 + 2 + 2 : 코너를 4번\n\n=> 증가값은 항상 8이다.\n\n이러한 규칙을 통해 일직선상 구슬들의 인덱스를 알아낼 수 있다.\n\n## 상세 구현\n\n블리자드는 네 가지 함수로 구현했다.  \n코드는 [21611.cpp](https://github.com/wndgur2/wndgur2.github.io/tree/main/algorithm/cpp/21611_%EB%A7%88%EB%B2%95%EC%82%AC_%EC%83%81%EC%96%B4%EC%99%80_%EB%B8%94%EB%A6%AC%EC%9E%90%EB%93%9C/21611.cpp) 파일을 참조하시면 됩니다.\n\n```cpp\n// D방향으로 S만큼 구슬을 파괴하고, 그 자리를 0으로 대체한다.\nvoid 구슬파괴(marbles, D, S)\n\n// 배열 중간에 빈자리인 0을 제거하고 다음 칸의 구슬을 앞으로 당긴다. 당길 수 없을 때까지 반복한다.\nvoid 구슬당기기(marbles)\n\n// 4개 이상 연속된 구슬을 0으로 대체하고 당기기를 폭발이 없을 때까지 반복한다. 그 점수를 리턴한다.\nint 구슬폭발(marbles)\n\n// 문제의 규칙에 따라 구슬을 재조합한다.\nvector<vector<int>> 구슬변화(marbles)\n```\n\n이 함수들을 사용하기 전에, input으로 주어지는 테이블을, 중앙에서부터 달팽이 껍질 모양으로 따라나가면서  \n1차원 벡터로 바꾸어주는 작업을 했다.\n\n이후에는 위 네 함수를 적절히 사용해 해결했다.\n\n---\n\n### Code\n\n<!-- CODE-APPENDED:21611.cpp -->\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvoid 구슬파괴(vector<int> &marbles_, int direction, int scope){\n    int initial_increment[] = {7, 3, 1, 5}; // 상하좌우\n    int marble_index, cur_increment, j;\n\n    cur_increment = initial_increment[direction-1];\n    marble_index = initial_increment[direction-1];\n    \n    for(j=0; j<scope; j++){\n        marbles_[marble_index] = 0;\n        cur_increment += 8;\n        marble_index += cur_increment;\n    }\n}\n\nvoid 구슬당기기(vector<int> &marbles_){\n    int n = marbles_.size();\n    marbles_.erase(remove(marbles_.begin()+1, marbles_.end(), 0), marbles_.end());\n    while(marbles_.size() < n)\n        marbles_.push_back(0);\n    return;\n}\n\nint 구슬폭발(vector<int> &marbles_){\n    int found_new_i = 0, cur_n = 0, k, l, result = 0;\n    bool is_blown_up = true;\n    while(is_blown_up){\n        is_blown_up = false;\n        for(k=1; k<marbles_.size(); ++k){ // 0번은 마법사 상어니까 1번부터\n            if(marbles_[k] != cur_n){\n                if(k - found_new_i > 3){ // 폭발 발생\n                    result += cur_n * (k-found_new_i);\n                    is_blown_up = true;\n                    for(l=found_new_i; l<k; ++l)\n                        marbles_[l] = 0;\n                }\n                cur_n = marbles_[k];\n                found_new_i = k;\n            }\n            if(marbles_[k] == 0) break;\n        }\n        구슬당기기(marbles_);\n    }\n    return result;\n}\n\nvector<int> 구슬변화(vector<int> &marbles_){\n    vector<int> new_marbles = {0};\n    int max_size = marbles_.size();\n    int group_size = 0, cur_n = marbles_[1], k, l;\n    for(k=1; k<max_size; ++k){ // 0번은 마법사 상어니까 1번부터\n        if(marbles_[k] != cur_n){ // 그룹 생성됨\n            if(new_marbles.size() < max_size) new_marbles.push_back(group_size);\n            else break;\n            if(new_marbles.size() < max_size) new_marbles.push_back(cur_n);\n            else break;\n            \n            if(marbles_[k] == 0) break;\n            \n            cur_n = marbles_[k];\n            group_size = 0;\n        }\n\n        ++group_size;\n    }\n    while(new_marbles.size() < max_size)\n        new_marbles.push_back(0);\n\n    return new_marbles;\n}\n\nint main(){\n    int N, M, i, j, answer = 0;\n    cin >> N >> M;\n    vector<vector<int>> table(N, vector<int> (N));\n    vector<int> marbles = {};\n\n    for(i=0; i<N; ++i)\n        for(j=0; j<N; ++j)\n            cin >> table[i][j];\n\n    // 달팽이 모양 테이블을 1자로 펴서 1D로 저장하기\n    int current_length = 0, side_length = 1, y = int(N/2), x = int(N/2), turn = 0;\n    vector<vector<int>> directions = {{0, -1}, {1, 0}, {0, 1}, {-1, 0}}; // 좌하우상\n    int i_dir = 0;\n\n    for(i=0; i<N*N; ++i){\n        ++current_length;\n        marbles.push_back(table[y][x]);\n            \n        y += directions[i_dir][0];\n        x += directions[i_dir][1];\n\n        if(current_length % side_length == 0){\n            current_length = 0;\n            i_dir = (i_dir+1) % 4;\n            if(++turn%2 == 0) ++side_length;\n        }\n    }\n\n    // 블리자드 맛좀 보소\n    int D, S; // 방향, 거리\n\n    for(i=0; i<M; ++i){\n        cin >> D >> S;\n        구슬파괴(marbles, D, S);\n        구슬당기기(marbles);\n        answer += 구슬폭발(marbles);\n        marbles = 구슬변화(marbles);\n    }\n\n    cout << answer << endl;\n\n    return 0;\n}\n```\n",
    "tags": [
      "cpp",
      "구현"
    ],
    "date_started": "2023.07.07",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/algorithm/%EB%A7%88%EB%B2%95%EC%82%AC_%EC%83%81%EC%96%B4%EC%99%80_%EB%B8%94%EB%A6%AC%EC%9E%90%EB%93%9C.md",
    "preview": ""
  },
  {
    "id": "posts/algorithm/레이저_통신.md",
    "category": "Algorithm",
    "title": "레이저 통신",
    "content": "\n# [문제](https://www.acmicpc.net/problem/6087)\n\n기차에서 하느라 목소리 좋은 규빈이가 대신 읽어주어 감사하다~\n\n# 문제 풀이\n각 칸까지 도달하기 위한 최소 거울 수를 2차원 벡터(`map_mirror`)에 저장하면서 DFS를 수행했습니다.  \n최소 거울 수가 최소 이동거리를 보장하기 때문에 별도로 최소 이동거리 검증은 하지 않았습니다.  \n\nDFS에서는 각 칸에서 꺾는지 여부를 확인해야 하므로 매개변수로 방향(`direction`)을 전달했습니다.  \n\n코드를 간결하게 하기 위해:  \n- `d_loc`: 크기가 1인 4방향 벡터를 저장  \n- `move(int direction, vector<int> loc)`: 현재 좌표에서 direction으로 이동한 좌표를 리턴  \n- `check_no_wall(vector<int> loc)`: 해당 좌표가 유효한지 확인  \n\n중간에 디버깅 출력을 위해 DFS 과정을 출력하는 코드가 있습니다. (line 35)\n\n# 코드\n```cpp\n#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<vector<int>> d_loc{{-1, 0}, {0, 1}, {1, 0}, {0, -1}}; // dy, dx\nvector<vector<char>> map_; // 각 칸의 character\nvector<vector<int>> map_mirror; // 각 칸까지 가기 위한 최소 거울 수\nint w, h, i, j;\n\nvector<int> move(int direction, vector<int> loc){\n  vector<int> new_loc = loc;\n  new_loc[0] += d_loc[direction][0];\n  new_loc[1] += d_loc[direction][1];\n  return new_loc;\n}\n\nbool check_no_wall(vector<int> loc){\n  if((loc[0] < 0) || (loc[1] < 0)) return false;\n  if((loc[0] >= h) || (loc[1] >= w)) return false;\n  if(map_[loc[0]][loc[1]] == '*') return false;\n  return true;\n}\n\nvoid dfs(int direction, vector<int> loc){\n  vector<int> new_loc;\n  int new_direction, is_turned;\n  for(int d=0; d<4; d++){\n    new_direction = (direction+d) % 4;\n    new_loc = move(new_direction, loc);\n    is_turned = (d==0 ? 0 : 1);\n    if(check_no_wall(new_loc)){\n      if(map_mirror[loc[0]][loc[1]] < map_mirror[new_loc[0]][new_loc[1]]){\n        map_mirror[new_loc[0]][new_loc[1]] = map_mirror[loc[0]][loc[1]] + is_turned;\n        dfs(new_direction, new_loc);\n      }\n    }\n  }\n}\n\nint main(){\n  cin >> w >> h;\n  for(i=0; i<h; i++){\n    vector<char> tmp;\n    vector<int> tmp_;\n    map_.push_back(tmp);\n    map_mirror.push_back(tmp_);\n    for(j=0; j<w; j++){\n      map_[i].push_back(' ');\n      map_mirror[i].push_back(h*w);\n    }\n  }\n  int start_x, start_y, end_x, end_y;\n  bool found_C = false;\n  for(i=0; i<h; i++){\n    for(j=0; j<w; j++){\n      cin >> map_[i][j];\n      if(map_[i][j] == 'C'){\n        if(found_C){\n          end_y = i; end_x = j;\n        } else{\n          start_y = i; start_x = j;\n          found_C = true;\n        }\n      }\n    }\n  }\n  map_[start_y][start_x] = '.';\n  map_mirror[start_y][start_x] = 0;\n  for(i=0; i<4; i++)\n    dfs(i, {start_y, start_x});\n  cout << map_mirror[end_y][end_x] << endl;\n  return 0;\n}\n```",
    "tags": [
      "DFS",
      "cpp",
      "shortest-path"
    ],
    "date_started": "2023.06.24",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/algorithm/%EB%A0%88%EC%9D%B4%EC%A0%80_%ED%86%B5%EC%8B%A0.md",
    "preview": ""
  },
  {
    "id": "posts/algorithm/N과_M_(1).md",
    "category": "Algorithm",
    "title": "N과 M (1)",
    "content": "\n# [문제](https://www.acmicpc.net/problem/15649)\n\n1부터 N까지 수 중에 M개의 수를 포함하는 모든 순열을 사전순으로 출력하는 문제입니다.\n\n# 문제 풀이\n\nN이 최대 8개이므로 할만하다고 생각해서 완전탐색을 먼저 시도했다.  \nBFS보다 DFS가 메모리를 덜 먹는다고 하여 recursion으로 dfs를 구현했다.\n\n# 코드\n\n```cpp\n#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std; // N과 M\n\nvoid dfs(int n, int m, vector<int> nums){\n  if(m == 0){\n    for(int i = 0; i < nums.size(); i++)\n      printf(\"%d \", nums[i]);\n    printf(\"\\n\");\n    return;\n  }\n  for(int i = 1; i <= n; i++){\n    if(find(nums.begin(), nums.end(), i) == nums.end()){\n      nums.push_back(i);\n      dfs(n, m - 1, nums);\n      nums.pop_back();\n    }\n  }\n}\n\nint main(){\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  vector<int> nums;\n  dfs(n, m, nums);\n  return 0;\n}\n```\n\n감사합니다.\n",
    "tags": [
      "DFS",
      "backtracking",
      "cpp"
    ],
    "date_started": "2023.05.06",
    "github": "https://github.com/wndgur2/BlogDB/blob/main/posts/algorithm/N%EA%B3%BC_M_(1).md",
    "preview": ""
  }
]