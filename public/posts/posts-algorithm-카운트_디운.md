
# [문제](https://school.programmers.co.kr/learn/courses/30/lessons/131129#)
## 문제 설명
프로그래머스 다트 협회에서는 매년마다 새로운 특수 룰로 다트 대회를 개최합니다. 이번 대회의 룰은 **"카운트 다운"**으로 **"제로원"** 룰의 변형 룰입니다.  

"카운트 다운"은 게임이 시작되면 무작위로 점수가 정해지고, 다트를 던지면서 점수를 깎아 정확히 0점으로 만드는 게임입니다.  
단, 남은 점수보다 큰 점수로 득점하면 버스트가 되며 실격합니다.

다음 그림은 다트 과녁입니다.  

![Image](https://github.com/user-attachments/assets/7353a57f-16c2-4cfa-bcd0-9a3b6056481b)

다트 과녁에는 1부터 20까지의 수가 하나씩 있고 각 수마다 "싱글", "더블", "트리플" 칸이 있습니다.  
- "싱글": 해당 수만큼 점수 획득  
- "더블": 해당 수의 두 배 점수 획득  
- "트리플": 해당 수의 세 배 점수 획득  

가운데에는 "불"과 "아우터 불"이 있는데 "카운트 다운" 게임에서는 구분 없이 50점을 얻습니다.

대회는 토너먼트로 진행되며 한 게임에는 두 선수가 참가합니다. 게임은 두 선수가 교대로 한 번씩 던지는 라운드 방식으로 진행됩니다.  
가장 먼저 0점을 만든 선수가 승리합니다.  
만약 두 선수가 같은 라운드에 0점을 만들면, 두 선수 중 **"싱글" 또는 "불"을 더 많이 던진 선수**가 승리하며, 그마저도 같다면 **선공인 선수**가 승리합니다.

다트 실력에 자신 있던 종호는 이 대회에 출전하기로 했습니다.  
최소한의 다트로 0점을 만드는 게 가장 중요하고, 그러한 방법이 여러 가지가 있다면 "싱글" 또는 "불"을 최대한 많이 던지는 방법을 선택해야 합니다.

목표 점수 `target`이 매개변수로 주어졌을 때,  
- 최선의 경우 던질 다트 수와  
- 그때의 "싱글" 또는 "불"을 맞춘 횟수(합)  

를 순서대로 배열에 담아 return 하도록 `solution` 함수를 완성해 주세요.

## 제한사항
- 1 ≤ target ≤ 100,000  

## 입출력 예
| target | result |
| ------ | ------ |
| 21     | [1, 0] |
| 58     | [2, 2] |

## 입출력 예 설명
### 입출력 예 #1
- 7 트리플로 21점을 만들 수 있습니다.

### 입출력 예 #2
- 불 + 8 싱글로 58점을 만들 수 있습니다.

# 문제 풀이

첫 시도는 bfs였다.

target이 최대 십만이기에 bfs 경우만 잘 정리하면 가능할 것 같았지만, 경우를 축소하기가 쉽지 않았다.

bfs 코드를 작성하고 보니 dp 문제인게 보였다.

target을 향해 point를 쌓아나가는 과정이 있기 때문이다.

그 중에 try가 가장 적고, bullOrSingle이 가장 많은 경우를 고르면 된다.

# 코드
```javascript
// target으로 가는 dp

function solution(target) {
    const dp = Array(100001).fill(0).map(v=>[-1,-1])
    dp[0][0] = 0
    dp[0][1] = 0
    
    for(let i=1; i<=20; i++){
        dp[i][0]=1
        dp[i][1]=1
    }
    dp[50][0]=1
    dp[50][1]=1
    
    for(let i=0; i<=target; i++){
        if(i>=50){
            dp[i][0] = dp[i-50][0]+1
            dp[i][1] = dp[i-50][1]+1
        }
        let d1;
        for(let j=1; j<=20; j++){
            for(let k=1; k<=3; k++){
                if(k==1) d1=1
                else d1=0
                if(i-j*k<0) break
                const newTries = dp[i-j*k][0] + 1
                const newBullOrSingles = dp[i-j*k][1] + d1
                
                if(newTries<dp[i][0] ||
                    newTries==dp[i][0] && newBullOrSingles>dp[i][1] ||
                    dp[i][0]==-1
                  ){
                    dp[i][0] = newTries
                    dp[i][1] = newBullOrSingles
                }
            }
        }
    }
    return dp[target]
}
```